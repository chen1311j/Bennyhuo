<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennyhuo</title>
  
  <subtitle>编程、教学 &amp; Kotlin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2019-04-06T01:23:19.972Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Bennyhuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>破解 Kotlin 协程 - 入门篇</title>
    <link href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/"/>
    <id>https://www.bennyhuo.com/2019/04/01/basic-coroutines/</id>
    <published>2019-04-01T14:19:33.923Z</published>
    <updated>2019-04-06T01:23:19.972Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>假定你对协程（Coroutine）一点儿都不了解。<br>通过阅读本文看看是否能让你明白协程是怎么一回事。</p></blockquote><h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h2><p>我之前写过一些协程的文章，很久以前了。那会儿还是很痛苦的，毕竟 <a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a> 这样强大的框架还在襁褓当中，于是乎我写的几篇协程的文章几乎就是在告诉大家如何写这样一个框架——那种感觉简直糟糕透了，因为没有几个人会有这样的需求。</p><p>这次准备从协程用户（也就是程序员你我他啦）的角度来写一下，希望对大家能有帮助。</p><h2 id="2-需求确认"><a href="#2-需求确认" class="headerlink" title="2. 需求确认"></a>2. 需求确认</h2><p>在开始讲解协程之前，我们需要先确认几件事儿：</p><ol><li>你用过线程对吧？</li><li>你写过回调对吧？</li><li>你用过 RxJava 类似的框架吗？</li></ol><p>看下你的答案：</p><ul><li>如果上面的问题的回答都是 “Yes”，那么太好了，这篇文章非常适合你，因为你已经意识到回调有多么可怕，并且找到了解决方案；</li><li>如果前两个是 “Yes”，没问题，至少你已经开始用回调了，你是协程潜在的用户；</li><li>如果只有第一个是 “Yes”，那么，可能你刚刚开始学习线程，那你还是先打好基础再来吧~</li></ul><a id="more"></a><h2 id="3-一个常规例子"><a href="#3-一个常规例子" class="headerlink" title="3. 一个常规例子"></a>3. 一个常规例子</h2><p>我们通过 Retrofit 发送一个网络请求，其中接口如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span> login: <span class="type">String</span>)</span></span>: Call&lt;User&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: String, <span class="keyword">val</span> name: String, <span class="keyword">val</span> url: String)</span><br></pre></td></tr></table></figure><p>Retrofit 初始化如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> gitHubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们请求网络时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitHubServiceApi.getUser(<span class="string">"bennyhuo"</span>).enqueue(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        handler.post &#123; showError(t) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        handler.post &#123; response.body()?.let(::showUser) ?: showError(NullPointerException()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请求结果回来之后，我们切换线程到 UI 线程来展示结果。这类代码大量存在于我们的逻辑当中，它有什么问题呢？</p><ul><li>通过 Lambda 表达式，我们让线程切换变得不是那么明显，但它仍然存在，一旦开发者出现遗漏，这里就会出现问题</li><li>回调嵌套了两层，看上去倒也没什么，但真实的开发环境中逻辑一定比这个复杂的多，例如登录失败的重试</li><li>重复或者分散的异常处理逻辑，在请求失败时我们调用了一次 <code>showError</code>，在数据读取失败时我们又调用了一次，真实的开发环境中可能会有更多的重复</li></ul><p>Kotlin 本身的语法已经让这段代码看上去好很多了，如果用 Java 写的话，你的直觉都会告诉你：你在写 Bug。</p><blockquote><p>如果你不是 Android 开发者，那么你可能不知道 handler 是什么东西，没关系，你可以替换为 <code>SwingUtilities.invokeLater{ ... }</code> (Java Swing)，或者 <code>setTimeout({ ... }, 0)</code> (Js) 等等。</p></blockquote><h2 id="4-改造成协程"><a href="#4-改造成协程" class="headerlink" title="4. 改造成协程"></a>4. 改造成协程</h2><p>你当然可以改造成 RxJava 的风格，但 RxJava 比协程抽象多了，因为除非你熟练使用那些 operator，不然你根本不知道它在干嘛（试想一下 <code>retryWhen</code>）。协程就不一样了，毕竟编译器加持，它可以很简洁的表达出代码的逻辑，不要想它背后的实现逻辑，它的运行结果就是你直觉告诉你的那样。</p><p>对于 Retrofit，改造成协程的写法，有两种，分别是通过 CallAdapter 和 suspend 函数。</p><h3 id="4-1-CallAdapter-的方式"><a href="#4-1-CallAdapter-的方式" class="headerlink" title="4.1 CallAdapter 的方式"></a>4.1 CallAdapter 的方式</h3><p>我们先来看看 CallAdapter 的方式，这个方式的本质是让接口的方法返回一个协程的 Job：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span> login: <span class="type">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意 Deferred 是 Job 的子接口。</p></blockquote><p>那么我们需要为 Retrofit 添加对 <code>Deferred</code> 的支持，这需要用到开源库：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'</span></span><br></pre></td></tr></table></figure><p>构造 Retrofit 实例时添加：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> gitHubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            <span class="comment">//添加对 Deferred 的支持</span></span><br><span class="line">            .addCallAdapterFactory(CoroutineCallAdapterFactory())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时候我们发起请求就可以这么写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(gitHubServiceApi.getUser(<span class="string">"bennyhuo"</span>).await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明： <code>Dispatchers.Main</code> 在不同的平台上的实现不同，如果在 Android 上为 <code>HandlerDispatcher</code>，在 Java Swing 上为 <code>SwingDispatcher</code> 等等。</p></blockquote><p>首先我们通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个，依次为协程上下文、协程启动模式、协程体：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, <span class="comment">// 上下文</span></span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,  <span class="comment">// 启动模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.()</span></span> -&gt; <span class="built_in">Unit</span> <span class="comment">// 协程体</span></span><br><span class="line">): Job</span><br></pre></td></tr></table></figure><p><strong>启动模式</strong>不是一个很复杂的概念，不过我们暂且不管，默认直接允许调度执行。</p><p><strong>上下文</strong>可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保 <code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己在 <code>launch</code> 的协程体内部进行线程切换、或者启动运行在其他有线程切换能力的上下文的协程）。</p><p>换句话说，在例子当中整个 <code>launch</code> 内部<strong>你看到的代码</strong>都是运行在 UI 线程的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。这看上去有些费解，因为直觉告诉我们，<code>getUser</code> 返回了一个 <code>Deferred</code> 类型，它的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么 <code>await</code> 不会阻塞 UI 线程吗？</p><p>答案是：不会。当然不会，不然那 <code>Deferred</code> 与 <code>Future</code> 又有什么区别呢？这里 <code>await</code> 就很可疑了，因为它实际上是一个 suspend 函数，这个函数只能在协程体或者其他 suspend 函数内部被调用，它就像是回调的语法糖一样，它通过一个叫 <code>Continuation</code> 的接口的实例来返回结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.3"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.3 的源码其实并不是很直接，尽管我们可以再看下 <code>Result</code> 的源码，但我不想这么做。更容易理解的是之前版本的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家一下就能明白，这其实就是个回调嘛。如果还不明白，那就对比下 Retrofit 的 <code>Callback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, Throwable t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有结果正常返回的时候，<code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常，简直与 <code>Callback</code> 一模一样。</p><p>所以这时候你应该明白，这段代码的执行流程本质上是一个异步回调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//showUser 在 await 的 Continuation 的回调函数调用后执行</span></span><br><span class="line">        showUser(gitHubServiceApi.getUser(<span class="string">"bennyhuo"</span>).await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而代码之所以可以看起来是同步的，那就是编译器的黑魔法了，你当然也可以叫它“语法糖”。</p><p>这时候也许大家还是有问题：我并没有看到 <code>Continuation</code> 啊，没错，这正是我们前面说的编译器黑魔法了，在 Java 虚拟机上，<code>await</code> 这个方法的签名其实并不像我们看到的那样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> suspend <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br></pre></td></tr></table></figure><p>它真实的签名其实是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlinx/coroutines/Deferred.await (Lkotlin/coroutines/Continuation;)Ljava/lang/Object;</span><br></pre></td></tr></table></figure><p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 的这么个函数，所以前面的代码我们可以大致理解为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意以下不是正确的代码，仅供大家理解协程使用</span></span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    gitHubServiceApi.getUser(<span class="string">"bennyhuo"</span>).await(<span class="keyword">object</span>: Continuation&lt;User&gt;&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">                showUser(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>&#123;</span><br><span class="line">                showError(exception)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 <code>await</code> 当中，大致就是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意以下并不是真实的实现，仅供大家理解协程使用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">User</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">    ... <span class="comment">// 切到非 UI 线程中执行，等待结果返回</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> user = ...</span><br><span class="line">        handler.post&#123; continuation.resume(user) &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e: Exception) &#123;</span><br><span class="line">        handler.post&#123; continuation.resumeWithException(e) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的回调大家一看就能明白。讲了这么多，请大家记住一点：从执行机制上来讲，协程跟回调没有什么本质的区别。</p><h3 id="4-2-suspend-函数的方式"><a href="#4-2-suspend-函数的方式" class="headerlink" title="4.2 suspend 函数的方式"></a>4.2 suspend 函数的方式</h3><p>suspend 函数是 Kotlin 编译器对协程支持的唯一的黑魔法（表面上的，还有其他的我们后面讲原理的时候再说）了，我们前面已经通过 <code>Deferred</code> 的 <code>await</code> 方法对它有了个大概的了解，我们再来看看 Retrofit 当中它还可以怎么用。</p><blockquote><p>Retrofit 当前的 release 版本是 2.5.0，还不支持 suspend 函数。因此想要尝试下面的代码，需要最新的 Retrofit 源码的支持；当然，也许你看到这篇文章的时候，Retrofit 的新版本已经支持这一项特性了呢。</p></blockquote><p>首先我们修改接口方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span> login: <span class="type">String</span>)</span></span>: User</span><br></pre></td></tr></table></figure><p>这种情况 Retrofit 会根据接口方法的声明来构造 <code>Continuation</code>，并且在内部封装了 <code>Call</code> 的异步请求（使用 enqueue），进而得到 <code>User</code> 实例，具体原理后面我们有机会再介绍。使用方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(gitHubServiceApi.getUser(<span class="string">"bennyhuo"</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的执行流程与 <code>Deferred.await</code> 类似，我们就不再详细分析了。</p><h2 id="5-协程到底是什么"><a href="#5-协程到底是什么" class="headerlink" title="5. 协程到底是什么"></a>5. 协程到底是什么</h2><p>好，坚持读到这里的朋友们，你们一定是异步代码的“受害者”，你们肯定遇到过“回调地狱”，它让你的代码可读性急剧降低；也写过大量复杂的异步逻辑处理、异常处理，这让你的代码重复逻辑增加；因为回调的存在，还得经常处理线程切换，这似乎并不是一件难事，但随着代码体量的增加，它会让你抓狂，线上上报的异常因线程使用不当导致的可不在少数。</p><p>而<strong>协程</strong>可以帮你优雅的处理掉这些。</p><p>协程本身是一个脱离语言实现的概念，我们“很严谨”（哈哈）的给出维基百科的定义：</p><blockquote><p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p></blockquote><p>简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。这里还是需要有点儿操作系统的知识的，我们在 Java 虚拟机上所认识到的线程大多数的实现是映射到内核的线程的，也就是说线程当中的代码逻辑在线程抢到 CPU 的时间片的时候才可以执行，否则就得歇着，当然这对于我们开发者来说是透明的；而经常听到所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。</p><blockquote><p>关于并发和并行：正因为 CPU 时间片足够小，因此即便一个单核的 CPU，也可以给我们营造多任务同时运行的假象，这就是所谓的“并发”。并行才是真正的同时运行。并发的话，更像是 Magic。</p></blockquote><p>如果大家熟悉 Java 虚拟机的话，就想象一下 Thread 这个类到底是什么吧，为什么它的 run 方法会运行在另一个线程当中呢？谁负责执行这段代码的呢？显然，咋一看，Thread 其实是一个对象而已，run 方法里面包含了要执行的代码——仅此而已。协程也是如此，如果你只是看标准库的 API，那么就太抽象了，但我们开篇交代了，学习协程不要上来去接触标准库，<a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a> 框架才是我们用户应该关心的，而这个框架里面对应于 Thread 的概念就是 Job 了，大家可以看下它的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCompleted: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCancelled: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> suspend <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看 Thread 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException  </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们非常贴心的省略了一些注释和不太相关的接口。我们发现，Thread 与 Job 基本上功能一致，它们都承载了一段代码逻辑（前者通过 run 方法，后者通过构造协程用到的 Lambda 或者函数），也都包含了这段代码的运行状态。</p><p>而真正调度时二者才有了本质的差异，具体怎么调度，我们只需要知道调度结果就能很好的使用它们了。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>我们先通过例子来引入，从大家最熟悉的代码到协程的例子开始，演化到协程的写法，让大家首先能从感性上对协程有个认识，最后我们给出了协程的定义，也告诉大家协程究竟能做什么。</p><p>这篇文章没有追求什么内部原理，只是企图让大家对协程怎么用有个第一印象。如果大家仍然感觉到迷惑，不怕，后面我将再用几篇文章从例子入手来带着大家分析协程的运行，而原理的分析，会放到大家能够熟练掌握协程之后再来探讨。</p><hr><ul><li>Bennyhuo 所在的组招 Android 实习生啦</li><li>主要面向 2020 年（暑期实习）毕业的计算机相关专业本科及以上的在校生</li><li>Java 基础扎实者优先，熟悉 Kotlin 优先</li><li>腾讯地图相关业务，坐标 <strong>北京中关村</strong></li><li>有兴趣的小伙伴可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a> 哈~</li></ul><hr><p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;假定你对协程（Coroutine）一点儿都不了解。&lt;br&gt;通过阅读本文看看是否能让你明白协程是怎么一回事。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;1-引子&quot;&gt;&lt;a href=&quot;#1-引子&quot; class=&quot;headerlink&quot; title=&quot;1. 引子&quot;&gt;&lt;/a&gt;1. 引子&lt;/h2&gt;&lt;p&gt;我之前写过一些协程的文章，很久以前了。那会儿还是很痛苦的，毕竟 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlinx.coroutines&lt;/a&gt; 这样强大的框架还在襁褓当中，于是乎我写的几篇协程的文章几乎就是在告诉大家如何写这样一个框架——那种感觉简直糟糕透了，因为没有几个人会有这样的需求。&lt;/p&gt;&lt;p&gt;这次准备从协程用户（也就是程序员你我他啦）的角度来写一下，希望对大家能有帮助。&lt;/p&gt;&lt;h2 id=&quot;2-需求确认&quot;&gt;&lt;a href=&quot;#2-需求确认&quot; class=&quot;headerlink&quot; title=&quot;2. 需求确认&quot;&gt;&lt;/a&gt;2. 需求确认&lt;/h2&gt;&lt;p&gt;在开始讲解协程之前，我们需要先确认几件事儿：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;你用过线程对吧？&lt;/li&gt;&lt;li&gt;你写过回调对吧？&lt;/li&gt;&lt;li&gt;你用过 RxJava 类似的框架吗？&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;看下你的答案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果上面的问题的回答都是 “Yes”，那么太好了，这篇文章非常适合你，因为你已经意识到回调有多么可怕，并且找到了解决方案；&lt;/li&gt;&lt;li&gt;如果前两个是 “Yes”，没问题，至少你已经开始用回调了，你是协程潜在的用户；&lt;/li&gt;&lt;li&gt;如果只有第一个是 “Yes”，那么，可能你刚刚开始学习线程，那你还是先打好基础再来吧~&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>== 与 equals 居然结果不一样！</title>
    <link href="https://www.bennyhuo.com/2019/03/23/nan-equals/"/>
    <id>https://www.bennyhuo.com/2019/03/23/nan-equals/</id>
    <published>2019-03-23T00:03:30.056Z</published>
    <updated>2019-04-06T01:23:19.972Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-equals-意见不一致的情况"><a href="#与-equals-意见不一致的情况" class="headerlink" title="== 与 equals 意见不一致的情况"></a>== 与 equals 意见不一致的情况</h3><p>Kotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。</p><p>一般情况下这种说法是没问题的，连 IDE 也都会提示你：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg" alt=""></p><p>要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg" alt=""></p><p>这回居然不提示我了！所以这里面一定有鬼！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(equals)</span><br><span class="line">println(equals2)</span><br></pre></td></tr></table></figure><p>你们猜猜结果如何？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg" alt=""><br>我去，说好的 == 等价于 equals 呢？</p><p>完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。</p><a id="more"></a><p>以上运行结果是 kotlin.jvm 的，那么我们试试 kotlin.js，结果一样。Kotlin Native 说，他们俩的立场并不能代码我的，但我的结果与他们一样。。。所以这个不是 bug 呵。大家意见这么一致，是不是也想告诉我们点儿什么呢？</p><blockquote><p>NaN = Not a Number</p></blockquote><p>NaN 说了，我可是一翻脸不认人的主，我翻脸了连我自己都不认！额这，，么尴尬么。</p><h3 id="Jvm-的为什么"><a href="#Jvm-的为什么" class="headerlink" title="Jvm 的为什么"></a>Jvm 的为什么</h3><p>下面我们来剖析下在 Java 虚拟机上 == 和 equals 遇到 NaN 时都发生了什么吧。从字节码上来看，</p><p>== 映射成了 Java 虚拟机的指令，也就是 Java 代码中的 ==，按照规定，NaN 是不等于任何数值包括自己的，也就是说这个指令在任何值与 NaN 作比较时都会返回 false。字节码如下图所示：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532971508271.jpg" alt=""></p><p>而 equals 则映射成了 Java Float 的 equals 方法调用，我们来看下这个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>floatToIntBits</code> 的结果，主要返回浮点型的二进制表示，对于 NaN，那就是 0x7fc00000 了，这个是 IEEE 754 的规定。所以 equals 的执行 在 Java 虚拟机上就成了一个整数的比较，那么很显然会返回 true 了。</p><h3 id="JavaScript-的为什么"><a href="#JavaScript-的为什么" class="headerlink" title="JavaScript 的为什么"></a>JavaScript 的为什么</h3><p>在 Js Target 上，我们很容易的就可以看到编译后的 JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> equals_0 = kotlin_js_internal_FloatCompanionObject.NaN === kotlin_js_internal_FloatCompanionObject.NaN;</span><br><span class="line"><span class="keyword">var</span> equals2 = equals(kotlin_js_internal_FloatCompanionObject.NaN, kotlin_js_internal_FloatCompanionObject.NaN);</span><br></pre></td></tr></table></figure><p>而 <code>kotlin_js_internal_FloatCompanionObject.NaN</code> 又等价于 <code>Number.NaN</code>，因此上面的代码其实就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> equals_0 = <span class="built_in">Number</span>.NaN === <span class="built_in">Number</span>.NaN;</span><br><span class="line"><span class="keyword">var</span> equals2 = equals(<span class="built_in">Number</span>.NaN, <span class="built_in">Number</span>.NaN);</span><br></pre></td></tr></table></figure><p>对于第一行，JavaScript 与 Java 一样，规定 NaN 与自己不相等，所以返回 false，我们来看下第二行的 equals 函数的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Kotlin.equals = <span class="function"><span class="keyword">function</span> (<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj2 == <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj2 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj1 !== obj1) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj2 !== obj2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1 === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj1.equals === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj1.equals(obj2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1 === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> obj2 === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj1 === obj2 &amp;&amp; (obj1 !== <span class="number">0</span> || <span class="number">1</span> / obj1 === <span class="number">1</span> / obj2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj1 === obj2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532983608746.jpg" alt=""></p><p>这一句其实就是为 NaN 量身定做的，如果 obj1 跟自己不相等，那么一定是 NaN，就剩下的就看 obj2 是不是 NaN了。</p><h3 id="其他情况的讨论"><a href="#其他情况的讨论" class="headerlink" title="其他情况的讨论"></a>其他情况的讨论</h3><p>对于 NaN 在 == 与 equals 上表现出的不一致的情况，也是与平台相关的，而且 NaN 这个家伙本身的定义就是“六亲不认”，因此也讨论它的值的相等性是很无聊的一件事——除了看下 Kotlin 在各平台上的编译结果外。</p><p>实际上对于基本类型，Kotlin 的 == 和 equals 确实会做出不同的编译映射处理，但这样的处理在除了 NaN 外的所有场景下结果都是一致的，因此这二者可以认为除了 NaN 之外的所有情形下都是等价的。</p><hr><ul><li>Bennyhuo 所在的组招 Android 暑期实习生，有机会转正哦~</li><li>腾讯地图数据业务，坐标 <strong>北京中关村</strong></li><li>有兴趣的小伙伴可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a> 哈~</li></ul><hr><p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与-equals-意见不一致的情况&quot;&gt;&lt;a href=&quot;#与-equals-意见不一致的情况&quot; class=&quot;headerlink&quot; title=&quot;== 与 equals 意见不一致的情况&quot;&gt;&lt;/a&gt;== 与 equals 意见不一致的情况&lt;/h3&gt;&lt;p&gt;Kotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。&lt;/p&gt;&lt;p&gt;一般情况下这种说法是没问题的，连 IDE 也都会提示你：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;这回居然不提示我了！所以这里面一定有鬼！&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;println(equals)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(equals2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;你们猜猜结果如何？&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;我去，说好的 == 等价于 equals 呢？&lt;/p&gt;&lt;p&gt;完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于 Node.js 环境的 KotlinJs 工程的完美搭建</title>
    <link href="https://www.bennyhuo.com/2019/03/11/kotlin-nodejs/"/>
    <id>https://www.bennyhuo.com/2019/03/11/kotlin-nodejs/</id>
    <published>2019-03-10T22:51:20.136Z</published>
    <updated>2019-04-06T01:23:19.972Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要这样一篇文章"><a href="#为什么需要这样一篇文章" class="headerlink" title="为什么需要这样一篇文章"></a>为什么需要这样一篇文章</h3><p>我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。</p><p>而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。</p><p>这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：</p><ul><li>依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装</li><li>右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样</li><li>单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知</li></ul><p>基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。</p><p>接着，你需要在 IU 中安装 NodeJS 插件，如图：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg" alt=""></p><p>我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。</p><p>最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg" alt=""></p><p>工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg" alt=""></p><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg" alt=""></p><p>点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg" alt=""></p><p>首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。</p><p>当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs 编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compileKotlin2Js &#123;</span><br><span class="line">    kotlinOptions.moduleKind = <span class="string">'commonjs'</span></span><br><span class="line">    kotlinOptions.sourceMap = <span class="literal">true</span></span><br><span class="line">    kotlinOptions.metaInfo = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。</p><p>这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 <code>require(&#39;kotlin&#39;)</code>，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-js"</span></span><br><span class="line">    testImplementation <span class="string">"org.jetbrains.kotlin:kotlin-test-js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这怎么能运行得起来呢？</p><p>因此我们还需要一个插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.jetbrains.kotlin.frontend'</span></span><br></pre></td></tr></table></figure><p>为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">"https://dl.bintray.com/kotlin/kotlin-eap"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg" alt=""></p><p>而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kotlinFrontend &#123;</span><br><span class="line">    npm &#123;</span><br><span class="line">        dependency <span class="string">"style-loader"</span> <span class="comment">// production dependency</span></span><br><span class="line">        devDependency <span class="string">"karma"</span>     <span class="comment">// development dependency</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还支持 webpack 。</p><p>好啦，这时候再运行咱们的程序，就会得到结果：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg" alt=""></p><h2 id="体验一把-KotlinJs-的协程"><a href="#体验一把-KotlinJs-的协程" class="headerlink" title="体验一把 KotlinJs 的协程"></a>体验一把 KotlinJs 的协程</h2><p>首先添加依赖：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1'</span></span><br></pre></td></tr></table></figure><p>接着，编写我们的 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"[<span class="subst">$&#123;Date().toLocaleTimeString()&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">val</span> result = withContext(coroutineContext) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">4</span>)</span><br><span class="line">            <span class="string">"HelloWorld"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">"5. <span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg" alt=""></p><p>单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg" alt=""></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg" alt=""></p><p>我们可以看到 result 的值正是协程内部返回的 HelloWorld。</p><p>是不是很美？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑&gt;◡&lt;๑)۶</p><blockquote><p>从此，小伙伴们与 KotlinJs 过上了幸福的生活~</p></blockquote><hr><ul><li>Bennyhuo 所在的组招 Android 实习生啦</li><li>主要面向 2020（暑期实习）或者2021 （日常实习）年毕业的计算机相关专业本科及以上的在校生</li><li>Java 基础扎实者优先，熟悉 Kotlin 优先</li><li>腾讯地图相关业务，坐标 <strong>北京中关村</strong></li><li>有兴趣的小伙伴可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a> 哈~</li></ul><hr><p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么需要这样一篇文章&quot;&gt;&lt;a href=&quot;#为什么需要这样一篇文章&quot; class=&quot;headerlink&quot; title=&quot;为什么需要这样一篇文章&quot;&gt;&lt;/a&gt;为什么需要这样一篇文章&lt;/h3&gt;&lt;p&gt;我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。&lt;/p&gt;&lt;p&gt;而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。&lt;/p&gt;&lt;p&gt;这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装&lt;/li&gt;&lt;li&gt;右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样&lt;/li&gt;&lt;li&gt;单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>父类返回子类类型的函数写法</title>
    <link href="https://www.bennyhuo.com/2019/02/18/this-type/"/>
    <id>https://www.bennyhuo.com/2019/02/18/this-type/</id>
    <published>2019-02-18T04:38:06.021Z</published>
    <updated>2019-02-18T04:41:28.518Z</updated>
    
    <content type="html"><![CDATA[<p>今天的话题很简单，分享下也许对大家可以有帮助或者有启发。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>一看题目，有点儿晕。看个例子马上就明白了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBuilder</span></span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: EventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableEventBuilder</span> : <span class="type">EventBuilder</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="built_in">Long</span> = <span class="number">0</span>L</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(delay: <span class="type">Long</span>)</span></span>: DisposableEventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = <span class="keyword">object</span>: DisposableEvent(name, delay)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDisposableEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">            callback.onEvent(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去也没啥大毛病，用一下吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60</span>_000) <span class="comment">// ERROR!! </span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>我们调用完父类的 <code>retryLimit</code> 方法后，想要设置下 <code>delay</code>，结果发现没有这个方法。</p><blockquote><p>“我 X，这什么玩意儿”，你嘟囔了一句。</p></blockquote><a id="more"></a><p>因为返回的是父类，所以链式调用掉链子了。这就尴尬了。</p><h2 id="2-Scala-的解法"><a href="#2-Scala-的解法" class="headerlink" title="2. Scala 的解法"></a>2. Scala 的解法</h2><p>如果这段代码用 Scala 写，那么用 <code>this.type</code> 就简直完美的解决了这个问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> retryLimit: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retryLimit</span></span>(retryLimit: <span class="type">Int</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBuilder</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delay</span></span>(delay: <span class="type">Long</span>): <span class="type">SubBuilder</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">SubBuilder</span>().retryLimit(<span class="number">3</span>).delay(<span class="number">60000</span>)</span><br></pre></td></tr></table></figure><p>一点儿毛病都么有。</p><p>Kotlin 有这个特性吗？并没有。</p><h2 id="3-Kotlin-的解法"><a href="#3-Kotlin-的解法" class="headerlink" title="3. Kotlin 的解法"></a>3. Kotlin 的解法</h2><p>Kotlin 倒也不是没有办法解决这个问题，用下泛型就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBuilder</span>&lt;<span class="type">T : EventBuilder&lt;T</span>&gt;&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。</p><p>子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableEventBuilder</span> : <span class="type">EventBuilder</span>&lt;<span class="type">DisposableEventBuilder</span>&gt;</span>() &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的什么也不用动，这时候我们的链式调用就没啥问题了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60</span>_000) <span class="comment">// OK!!</span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperBuilder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> retryLimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">retryLimit</span><span class="params">(<span class="keyword">int</span> retryLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBuilder</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span>&lt;<span class="title">SubBuilder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SuperBuilder <span class="title">delay</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，今天就先这样~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的话题很简单，分享下也许对大家可以有帮助或者有启发。&lt;/p&gt;&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;一看题目，有点儿晕。看个例子马上就明白了：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EventBuilder&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; retryLimit = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;retryLimit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(retryLimit: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: EventBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.retryLimit = retryLimit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: PollingEvent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DisposableEventBuilder&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;EventBuilder&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; delay: &lt;span class=&quot;built_in&quot;&gt;Long&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(delay: &lt;span class=&quot;type&quot;&gt;Long&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: DisposableEventBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.delay = delay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;: DisposableEvent(name, delay)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDisposableEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            callback.onEvent(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;看上去也没啥大毛病，用一下吧：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DisposableEventBuilder().retryLimit(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .delay(&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;_000) &lt;span class=&quot;comment&quot;&gt;// ERROR!! &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们调用完父类的 &lt;code&gt;retryLimit&lt;/code&gt; 方法后，想要设置下 &lt;code&gt;delay&lt;/code&gt;，结果发现没有这个方法。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“我 X，这什么玩意儿”，你嘟囔了一句。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新年 Flag 以及论坛的一个所谓“Kotlin 不完全兼容 Java”的问题</title>
    <link href="https://www.bennyhuo.com/2019/02/05/2019-02-05/"/>
    <id>https://www.bennyhuo.com/2019/02/05/2019-02-05/</id>
    <published>2019-02-04T22:31:49.632Z</published>
    <updated>2019-02-18T04:44:42.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-新年立个-Flag"><a href="#0-新年立个-Flag" class="headerlink" title="0. 新年立个 Flag"></a>0. 新年立个 Flag</h3><p>首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。</p><p>每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。</p><p>我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。</p><a id="more"></a><p>一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。</p><p>下面我们说我们今天的正题：</p><h3 id="1-Kotlin-不能完全兼容-Java-吗？"><a href="#1-Kotlin-不能完全兼容-Java-吗？" class="headerlink" title="1. Kotlin 不能完全兼容 Java 吗？"></a>1. Kotlin 不能完全兼容 Java 吗？</h3><p>有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：</p><hr><p><strong>原帖开始</strong></p><p>Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，<br>但是在实际使用上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">    <span class="keyword">public</span> String mmm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiException</span><span class="params">(Throwable throwable, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(throwable);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> detailMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exception = ApiException(Throwable(),<span class="number">1</span>)</span><br><span class="line">exception.code <span class="comment">//正常</span></span><br><span class="line">exception.message <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure><p>错误信息如下：</p><blockquote><p>Overload resolution ambiguity. All these functions match. public final var message</p></blockquote><p>java中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ApiException(Throwable(),<span class="number">1</span>).message 完全正常</span><br></pre></td></tr></table></figure><p>java 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。</p><p><strong>原帖结束</strong></p><hr><p>看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。</p><p>题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？</p><p>当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）</p><p>好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：</p><p>先用 Java 包装一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtApiException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(ApiException a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在 Kotlin 里面这样调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = ApiException()</span><br><span class="line"><span class="keyword">val</span> t = (a <span class="keyword">as</span> Throwable).message</span><br><span class="line"><span class="keyword">val</span> r = ExtApiException.getMessage(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ApiException.<span class="title">realMessage</span><span class="params">()</span></span> = ExtApiException.getMessage(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">val</span> i = a.realMessage()</span><br></pre></td></tr></table></figure><p>这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。</p><h3 id="2-为什么-message-会和-getMessage-纠缠不清？"><a href="#2-为什么-message-会和-getMessage-纠缠不清？" class="headerlink" title="2. 为什么 message 会和 getMessage 纠缠不清？"></a>2. 为什么 message 会和 getMessage 纠缠不清？</h3><p>这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwable</span> <span class="keyword">public</span> <span class="keyword">constructor</span></span>(message: kotlin.String?, cause: kotlin.Throwable?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> message: kotlin.String? </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。</p><h3 id="3-真的没有办法通过-Kotlin-实现访问吗？"><a href="#3-真的没有办法通过-Kotlin-实现访问吗？" class="headerlink" title="3. 真的没有办法通过 Kotlin 实现访问吗？"></a>3. 真的没有办法通过 Kotlin 实现访问吗？</h3><p>Kotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exception = ApiException(Throwable(<span class="string">"ThrowableMessage"</span>),<span class="number">1</span>)</span><br><span class="line">println((exception <span class="keyword">as</span> java.lang.Throwable).getMessage())</span><br></pre></td></tr></table></figure><p>不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">property1</span><span class="params">(property: <span class="type">KProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">mutableProperty1</span><span class="params">(property: <span class="type">KMutableProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ApiException.throwableMessage: String?</span><br><span class="line">        <span class="keyword">get</span>() = property1(Throwable::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ApiException.apiMessage</span><br><span class="line">    <span class="keyword">get</span>() = mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">set</span>(<span class="keyword">this</span>, value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。</p><p>当然我们也可以通过是否可空来区分，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ApiException.apiMessage2: String</span><br><span class="line">    <span class="keyword">get</span>() = property1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>我们如果给 property1 的第二个泛型参数传入 <code>String</code> 而不是 <code>String?</code> 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。</p><p>这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloKt</span>$<span class="title">apiMessage</span>$2 <span class="keyword">extends</span> <span class="title">MutablePropertyReference1</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KMutableProperty1 INSTANCE = <span class="keyword">new</span> HelloKt$apiMessage$<span class="number">2</span>();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"message"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getSignature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"getMessage()Ljava/lang/String;"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> KDeclarationContainer <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Reflection.getOrCreateKotlinClass(ApiException.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(@Nullable Object receiver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ((ApiException)receiver).message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@Nullable Object receiver, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">      ((ApiException)receiver).message = (String)value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。</p><p>当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-新年立个-Flag&quot;&gt;&lt;a href=&quot;#0-新年立个-Flag&quot; class=&quot;headerlink&quot; title=&quot;0. 新年立个 Flag&quot;&gt;&lt;/a&gt;0. 新年立个 Flag&lt;/h3&gt;&lt;p&gt;首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。&lt;/p&gt;&lt;p&gt;每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。&lt;/p&gt;&lt;p&gt;我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 协程版的 AutoDispose</title>
    <link href="https://www.bennyhuo.com/2019/01/07/2019-01-07/"/>
    <id>https://www.bennyhuo.com/2019/01/07/2019-01-07/</id>
    <published>2019-01-07T04:19:27.797Z</published>
    <updated>2019-01-07T04:20:19.827Z</updated>
    
    <content type="html"><![CDATA[<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p><p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose" target="_blank" rel="noopener">AutoDispose</a>。</p><a id="more"></a><p>什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.view = view;</span><br><span class="line">    <span class="keyword">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我最近在想我们用协程其实也会有这样的问题呀：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClick &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>await</code> 返回结果之前我们就退出了当前的 <code>Activity</code> 那么，后面 <code>updateUI</code> 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 <code>onClickAutoDisposable</code> 嘛。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">android</span>.<span class="type">view</span>.<span class="type">View</span>?)</span></span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，不要脸的先抄 Anko 的 <code>onClick</code>，不同之处在于我们改了个名 XD。啊，还有我们加了个 <code>.asAutoDisposable(v)</code>，大家就假装有这个方法吧。。。</p><blockquote><p>(╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。</p></blockquote><p>OK OK，咱们下面来实现它。。想想，<code>GlobalScope.launch</code> 其实返回的是一个 <code>Job</code>，所以嘛，我们给 <code>Job</code> 搞一个扩展方法不就得了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>第二步，我们再偷偷的创建一个类，叫 <code>AutoDisposableJob</code>，抄一下前面的 <code>Listener</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoDisposableJob</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以使用这个扩展了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。&lt;/p&gt;&lt;p&gt;因此大家一定会用到 Uber 的开源框架 &lt;a href=&quot;https://github.com/uber/AutoDispose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AutoDispose&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</title>
    <link href="https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/"/>
    <id>https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/</id>
    <published>2018-12-30T23:43:13.084Z</published>
    <updated>2018-12-30T23:46:29.830Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我讲了用 <code>@CName</code> 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。</p><a id="more"></a><p>如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"JNI_OnLoad"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">JNI_OnLoad</span><span class="params">(vm: <span class="type">CPointer</span>&lt;<span class="type">JavaVMVar</span>&gt;, preserved: <span class="type">COpaquePointer</span>)</span></span>: jint &#123;</span><br><span class="line">    <span class="keyword">return</span> memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"JNI_OnLoad"</span>)</span><br><span class="line">        <span class="keyword">if</span>(result == JNI_OK)&#123;</span><br><span class="line">            <span class="keyword">val</span> env = envStorage.pointed!!.pointed!!</span><br><span class="line">            <span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">"com/example/hellojni/HelloJni"</span>.cstr.ptr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">            jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">            jniMethod[<span class="number">0</span>].name = <span class="string">"sayHello2"</span>.cstr.ptr</span><br><span class="line">            jniMethod[<span class="number">0</span>].signature = <span class="string">"()V"</span>.cstr.ptr</span><br><span class="line">            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"register say hello2, %d, %d"</span>, sizeOf&lt;CPointerVar&lt;JNINativeMethod&gt;&gt;(), sizeOf&lt;JNINativeMethod&gt;())</span><br><span class="line">        &#125;</span><br><span class="line">        JNI_VERSION_1_6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是先通过 <code>CName</code> 注解搞定 <code>JNI_OnLoad</code> 函数，让 Java 虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。</p><p>再说下 <code>memScope</code> 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 <code>memScope</code> 来提醒 Kotlin Native 这些变量需要来统一管理。</p><p>获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br></pre></td></tr></table></figure><p>这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，<code>CPointer</code> 的左值类型会映射成 <code>CPointerVar</code>，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。</p><p>接下来我们看这句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br></pre></td></tr></table></figure><p>C 版本的定义 <code>JavaVM</code> 其实本身也是一个指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br></pre></td></tr></table></figure><p>因此两个 <code>pointed</code> 的调用相当于获取到了 <code>JNIInvokeInterface</code> 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 <code>JNIEnv</code> 的操作了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br></pre></td></tr></table></figure><p>再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 <code>!!</code> 的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。</p><p>接下来我们要实现动态绑定了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">"com/example/hellojni/HelloJni"</span>.cstr.ptr)</span><br><span class="line"><span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">jniMethod[<span class="number">0</span>].name = <span class="string">"sayHello2"</span>.cstr.ptr</span><br><span class="line">jniMethod[<span class="number">0</span>].signature = <span class="string">"()V"</span>.cstr.ptr</span><br><span class="line">env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。</p><p>问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">var</span> RegisterNatives: kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlinx.cinterop.CPointer&lt;platform.android.JNIEnvVar <span class="comment">/* = kotlinx.cinterop.CPointerVarOf&lt;platform.android.JNIEnv /* = kotlinx.cinterop.CPointer&lt;platform.android.JNINativeInterface&gt; */</span>&gt; */&gt;?, platform.android.jclass? <span class="comment">/* = kotlinx.cinterop.CPointer&lt;out kotlinx.cinterop.CPointed&gt;? */</span>, kotlinx.cinterop.CPointer&lt;platform.android.JNINativeMethod&gt;?, platform.android.jint <span class="comment">/* = kotlin.Int */</span>) -&gt; platform.android.jint <span class="comment">/* = kotlin.Int */</span>&gt;&gt;? <span class="comment">/* compiled code */</span></span><br></pre></td></tr></table></figure><p>这其实就是 <code>RegisterNatives</code> 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。</p><p>这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。</p><p>简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。</p><p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我讲了用 &lt;code&gt;@CName&lt;/code&gt; 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</title>
    <link href="https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/"/>
    <id>https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/</id>
    <published>2018-12-16T23:12:05.412Z</published>
    <updated>2019-04-06T01:23:19.972Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 <code>CName</code> 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。</p><p>后来，我发现根本不需要这么麻烦啊。</p><a id="more"></a><p>我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java_包名_类名_方法名</span><br></pre></td></tr></table></figure><p>换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。</p><p>那么假如我们有下面的 Java 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJni</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们只要保证 so 库当中存在一个函数名为 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 并且返回 <code>jstring</code> 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。</p><p>我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">kotlin &#123;</span><br><span class="line">    targets &#123;</span><br><span class="line">        fromPreset(presets.androidNativeArm32, <span class="string">'HelloWorld'</span>) <span class="comment">// ① 配置为 Android 的工程</span></span><br><span class="line"></span><br><span class="line">        configure([HelloWorld]) &#123;</span><br><span class="line">            compilations.main.outputKinds <span class="string">'DYNAMIC'</span> <span class="comment">// ② 配置为动态链接库</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后随便创建一个文件，写一个全局函数，并用 <code>CName</code> 进行标注如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.cinterop.*</span><br><span class="line"><span class="keyword">import</span> platform.android.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_stringFromJNI"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">return</span> env.pointed.pointed!!.NewStringUTF!!.invoke(env, <span class="string">"This is from Kotlin Native!!"</span>.cstr.ptr)!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 <code>jstring</code> 这样的类型。</p><p>然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"knlib"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行时就可以调用 <code>stringFromJNI</code> 这个方法啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = (TextView)findViewById(R.id.hello_textview);</span><br><span class="line">tv.setText(stringFromJNI());</span><br></pre></td></tr></table></figure><p>接下来我再给大家看几个例子：</p><p>首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_sayHello"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"Hello %s"</span>, <span class="string">"Native"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在 Kotlin Native 当中调用 Java 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_callLoop"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLoop</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> jniEnvVal = env.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)</span><br><span class="line">        <span class="keyword">val</span> methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, <span class="string">"callFromNative"</span>.cstr.ptr, <span class="string">"()Ljava/lang/String;"</span>.cstr.ptr)</span><br><span class="line">        <span class="keyword">return</span> jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, <span class="literal">null</span>) <span class="keyword">as</span> jstring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>callFromNative</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callFromNative</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is from Java!!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。</p><p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a></p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 &lt;code&gt;CName&lt;/code&gt; 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。&lt;/p&gt;&lt;p&gt;后来，我发现根本不需要这么麻烦啊。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>也许你需要这个为数据类生成 DeepCopy 方法的库</title>
    <link href="https://www.bennyhuo.com/2018/12/02/deepcopy/"/>
    <id>https://www.bennyhuo.com/2018/12/02/deepcopy/</id>
    <published>2018-12-02T12:42:55.050Z</published>
    <updated>2019-04-06T01:23:19.972Z</updated>
    
    <content type="html"><![CDATA[<p>前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。</p><a id="more"></a><h2 id="我们有什么拷贝的需求？"><a href="#我们有什么拷贝的需求？" class="headerlink" title="我们有什么拷贝的需求？"></a>我们有什么拷贝的需求？</h2><p>我们知道 Kotlin 的 data class 出厂自带了一套 <code>copy</code> 方法，这个 <code>copy</code> 方法呢，就是实打实的一个浅拷贝，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>它的 <code>copy</code> 方法其实就相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name)</span></span> = GitUser(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成员是 <code>val</code> 那倒也还好，可如果是另一个数据类呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>我们如果需要 <code>copy</code> 一下 <code>Owner</code> 的话，我们就会发现新实例与旧实例共享了 <code>GitUser</code> 和 <code>Project</code> 的实例，万一项目的名称是可以改的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">var</span> name: String)</span><br></pre></td></tr></table></figure><p>新实例的 <code>project</code> 的名称我想更改一下，结果发现老实例的也被改了。</p><p>所以你需要一个 DeepCopy 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner &#123;</span><br><span class="line">        <span class="keyword">return</span> Owner(gitUser.copy(), project.copy())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你这时候想，虽然 <code>GitUser</code> 和 <code>Project</code> 这两个数据类内部的字段都是基本类型，用 <code>copy</code> 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 <code>deepCopy</code> 方法。。。</p><h2 id="来来来，先实现个简单的"><a href="#来来来，先实现个简单的" class="headerlink" title="来来来，先实现个简单的"></a>来来来，先实现个简单的</h2><p>天哪。那岂不是要写死了。</p><p>不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ</p><p>于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 <code>deepCopy</code> 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> T.<span class="title">deepCopy</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="comment">//①判断是否为数据类，不是的话直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">isData</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">primaryConstructor</span>!!.<span class="title">let</span> </span>&#123; primaryConstructor -&gt;</span><br><span class="line">        primaryConstructor.parameters</span><br><span class="line">            .map &#123; parameter -&gt;</span><br><span class="line">                <span class="keyword">val</span> value =</span><br><span class="line">                    (<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span> <span class="title">as</span> <span class="title">KClass</span>&lt;<span class="type">T</span>&gt;).<span class="title">declaredMemberProperties</span>.<span class="title">first</span> </span>&#123; it.name == parameter.name &#125;.<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">                <span class="comment">//③如果主构造器参数类型为数据类，递归调用</span></span><br><span class="line">                <span class="keyword">if</span> ((parameter.type.classifier <span class="keyword">as</span>? KClass&lt;*&gt;)?.isData == <span class="literal">true</span>) &#123;</span><br><span class="line">                    parameter to value?.deepCopy()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parameter to value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toMap()</span><br><span class="line">            .let(primaryConstructor::callBy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~*</p><p>其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻</p><p>这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-reflect:1.1.0'</span></span><br></pre></td></tr></table></figure><p>当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——</p><h2 id="来我们再试试注解处理器"><a href="#来我们再试试注解处理器" class="headerlink" title="来我们再试试注解处理器"></a>来我们再试试注解处理器</h2><p>注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。</p><p>不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 <code>Metadata</code> 来获取到这些信息。</p><p>读取 <code>Metadata</code> 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4"</span></span><br></pre></td></tr></table></figure><p>读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ</p><p>需要提一句的是，我们通过注解处理器生成的 <code>deepCopy</code> 可以添加默认参数，这里有不少细节需要处理，也是得益于 <code>Metadata</code> 的信息。</p><p>下面给大家看看例子吧：</p><p>首先添加依赖，配置注解处理器：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    <span class="comment">//kotlinx-metadata-jvm 目前部署到了这个仓库</span></span><br><span class="line">    maven &#123; url <span class="string">"https://kotlin.bintray.com/kotlinx/"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">apply plugin: <span class="string">"kotlin-kapt"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    kapt <span class="string">'com.bennyhuo.kotlin:deepcopy-compiler:1.1.0'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-annotations:1.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着为我们的数据类配置注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>build 一下，生成了下面的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner =</span><br><span class="line">    Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>我们看到，这已经跟出厂自带的 <code>copy</code> 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 <code>DeepCopy</code>，如果标注，就递归调用对应的 <code>deepCopy</code> 函数。</p><p>其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">()</span></span>: Owner = Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameter</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, List&lt;String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameterT</span>&lt;<span class="type">K: Number, V</span>&gt;</span>(<span class="keyword">val</span> map: HashMap&lt;K, V&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StarProjection</span></span>(<span class="keyword">val</span> map: List&lt;Map&lt;*, String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Variances1</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, <span class="keyword">out</span> List&lt;Number&gt;&gt;)</span><br></pre></td></tr></table></figure><p>如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。</p><h2 id="项目详情"><a href="#项目详情" class="headerlink" title="项目详情"></a>项目详情</h2><p>这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：<a href="https://github.com/enbandari/KotlinDeepCopy" target="_blank" rel="noopener">https://github.com/enbandari/KotlinDeepCopy</a>，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。</p><p>别犹豫了，Star 一波吧，千万别手软。</p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReleasableVar，可以为空的 Kotlin 非空类型 var</title>
    <link href="https://www.bennyhuo.com/2018/11/26/ReleasableVar/"/>
    <id>https://www.bennyhuo.com/2018/11/26/ReleasableVar/</id>
    <published>2018-11-25T23:28:47.024Z</published>
    <updated>2018-11-25T23:31:00.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-题外话：Hadi-的插件"><a href="#0-题外话：Hadi-的插件" class="headerlink" title="0. 题外话：Hadi 的插件"></a>0. 题外话：Hadi 的插件</h1><p>上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：</p><ul><li>Nyan Process Bar</li><li>Presentation Assistant</li></ul><p>也有同学问我ppt的，上周一的文章末尾有提供哈~</p><p>好了下面我们言归正传~</p><h1 id="1-描述下需求"><a href="#1-描述下需求" class="headerlink" title="1. 描述下需求"></a>1. 描述下需求</h1><p>前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 <code>null</code>，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// You cannot do that!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>你想着 Activity 的 <code>onStop</code> 调用了之后到被回收还得等一会儿呢，甚至 <code>onDestroy</code> 都会过一会儿才会被执行到，所以 <code>image</code> 可能会在内存被持有一段时间。所以幸好我们可以通过 <code>recycle</code> 方法先告诉 <code>Bitmap</code> 该释放内存了，不然的话我们只能等着 <code>Activity</code> 回收的时候 <code>image</code> 引用的对象才可以回收。</p><p>不可空类型能够置为 <code>null</code> 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。</p><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><p>想来想去，这个只能官方提供一个方法了，就像 <code>lateinitVar::isInitialized</code> 一样，提供一个 <code>lateinitVar::release()</code> 然后把 backingfield 的值给清空了不就好了吗？</p><p>这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Not Initialized or released already."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用的时候也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar <span class="keyword">by</span> releasableNotNull&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 <code>lateinit</code> 定义一个判断是否初始化的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.isInitialized()</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-干掉反射"><a href="#3-干掉反射" class="headerlink" title="3. 干掉反射"></a>3. 干掉反射</h1><p>然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 <code>null</code>，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。</p><p>其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 <code>KProperty0</code> 的 <code>receiver</code> 拿到属性代理对象了，所以我们需要的只是一个<code>WeakHashMap</code>，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 <code>WeakIdentityMap</code> 的集合，对应于有弱引用功能的 <code>IdentityHashMap</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> releasableRefs: WeakIdentityMap&lt;Any, MutableMap&lt;String, ReleasableNotNull&lt;*&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>那么我们只需要在前面的 <code>setValue</code> 当中绑定他们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> map = releasableRefs[thisRef]</span><br><span class="line">            <span class="keyword">if</span>(map == <span class="literal">null</span>)&#123;</span><br><span class="line">                map = HashMap()</span><br><span class="line">                releasableRefs[thisRef] = map</span><br><span class="line">            &#125;</span><br><span class="line">            map[property.name] = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>Map 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">            releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.isInitialized()</span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">        releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-怎么用？"><a href="#4-怎么用？" class="headerlink" title="4. 怎么用？"></a>4. 怎么用？</h1><p>啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 <code>KProperty0</code> 是啥，它其实就是一个顶级变量或者已经绑定完 <code>receiver</code> 的变量，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varInPackage = <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">"World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性我们通过下面的属性引用得到的就是 <code>KProperty0</code> 的实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::varInPackage</span><br><span class="line"></span><br><span class="line">Foo()::bar</span><br></pre></td></tr></table></figure><p>换句话说，我们开头给出的那个 <code>image</code> 的例子就可以这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        image.recycle()</span><br><span class="line">        ::image.release() <span class="comment">// You simply make the backing value null, thus making the gc of this Bitmap instance possible. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-你想直接用？"><a href="#5-你想直接用？" class="headerlink" title="5. 你想直接用？"></a>5. 你想直接用？</h1><p>我已经把这东西扔到 jCenter了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0&quot;</span><br></pre></td></tr></table></figure><p>完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：</p><p><a href="https://github.com/enbandari/ReleasableVar" target="_blank" rel="noopener">https://github.com/enbandari/ReleasableVar</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-题外话：Hadi-的插件&quot;&gt;&lt;a href=&quot;#0-题外话：Hadi-的插件&quot; class=&quot;headerlink&quot; title=&quot;0. 题外话：Hadi 的插件&quot;&gt;&lt;/a&gt;0. 题外话：Hadi 的插件&lt;/h1&gt;&lt;p&gt;上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nyan Process Bar&lt;/li&gt;&lt;li&gt;Presentation Assistant&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也有同学问我ppt的，上周一的文章末尾有提供哈~&lt;/p&gt;&lt;p&gt;好了下面我们言归正传~&lt;/p&gt;&lt;h1 id=&quot;1-描述下需求&quot;&gt;&lt;a href=&quot;#1-描述下需求&quot; class=&quot;headerlink&quot; title=&quot;1. 描述下需求&quot;&gt;&lt;/a&gt;1. 描述下需求&lt;/h1&gt;&lt;p&gt;前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 &lt;code&gt;null&lt;/code&gt;，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Activity &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; image: Bitmap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStart()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = Bitmap.create(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image.recycle()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// You cannot do that!!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018 JetBrains 开发者大会见闻</title>
    <link href="https://www.bennyhuo.com/2018/11/18/2018-JetBrains-Day/"/>
    <id>https://www.bennyhuo.com/2018/11/18/2018-JetBrains-Day/</id>
    <published>2018-11-18T06:23:04.343Z</published>
    <updated>2019-04-06T01:23:19.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。</p></blockquote><p>话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg" alt=""></p><a id="more"></a><p>大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。</p><p>开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）</p><p>JetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg" alt=""></p><p>印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg" alt=""></p><p>还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。</p><p>干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a>）。</p><p>Hadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。</p><p>中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg" alt=""></p><p>因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||</p><p>讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T</p><p>整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。</p><p>Hadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg" alt=""></p><p>还有一个是 Nyan 进度条的插件，很有趣：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg" alt=""></p><p>来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: GitUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，现在我们也可以用 <code>Deferred</code> 来接入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: Deferred&lt;GitUser&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。</p><p>听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)</p><p>不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！</p><p>下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg" alt=""></p><p>这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~</p><p>PS：茶歇的小饼干也很好吃啊！</p><hr><p>下午第一场 “如何优雅地使用数据类” 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~</p><p>链接：<a href="https://share.weiyun.com/5YMPoL4" target="_blank" rel="noopener">https://share.weiyun.com/5YMPoL4</a> 密码：sz4vyw</p><hr><p>Kotlin 中文站：<a href="https://www.kotlincn.net" target="_blank" rel="noopener">https://www.kotlincn.net</a><br>Kotlin 中文博客：<a href="https://www.kotliner.cn" target="_blank" rel="noopener">https://www.kotliner.cn</a><br>Kotlin 中文论坛：<a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">https://discuss.kotliner.cn</a><br>Ktor 中文站：<a href="https://ktor.kotlincn.net" target="_blank" rel="noopener">https://ktor.kotlincn.net</a></p><hr><p>欢迎关注：微信公众号 Kotlin</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>注解处理器教程[全]</title>
    <link href="https://www.bennyhuo.com/2018/10/03/apt-tutorials/"/>
    <id>https://www.bennyhuo.com/2018/10/03/apt-tutorials/</id>
    <published>2018-10-03T02:06:48.914Z</published>
    <updated>2019-04-06T01:23:19.971Z</updated>
    
    <content type="html"><![CDATA[<p>我在做 <a href="https://coding.imooc.com/class/232.html" target="_blank" rel="noopener">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a> 这门课的时候，顺便做了一个注解处理器的框架，叫 <a href="https://github.com/enbandari/TieGuanYin" target="_blank" rel="noopener">Tieguanyin(铁观音)</a>，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 <code>Intent</code> 来传递，有了这个框架我们就可以省去这个麻烦的步骤。</p><p>在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。</p><a id="more"></a><h1 id="视频源码"><a href="#视频源码" class="headerlink" title="视频源码"></a>视频源码</h1><p>见 Github 项目：<a href="https://github.com/enbandari/Apt-Tutorials" target="_blank" rel="noopener">Apt-Tutorials</a></p><h1 id="视频观看"><a href="#视频观看" class="headerlink" title="视频观看"></a>视频观看</h1><h2 id="1-课程简介"><a href="#1-课程简介" class="headerlink" title="1. 课程简介"></a>1. 课程简介</h2><p>作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728uxh61x.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728uxh61x.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=1</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1</a></p><h2 id="2-搭建工程"><a href="#2-搭建工程" class="headerlink" title="2. 搭建工程"></a>2. 搭建工程</h2><p>这一节主要介绍注解处理器工程的结构。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/o07284u5rju.html" target="_blank" rel="noopener">https://v.qq.com/x/page/o07284u5rju.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=2</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2" target="_blank" rel="noopener">https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2</a></p><h2 id="3-解析注解"><a href="#3-解析注解" class="headerlink" title="3. 解析注解"></a>3. 解析注解</h2><p>这一节主要介绍如何解析注解获取被标注的元素信息。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/z07286r97mz.html" target="_blank" rel="noopener">https://v.qq.com/x/page/z07286r97mz.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=3</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3</a></p><h2 id="4-生成常量"><a href="#4-生成常量" class="headerlink" title="4. 生成常量"></a>4. 生成常量</h2><p>这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/k0728tn7sty.html" target="_blank" rel="noopener">https://v.qq.com/x/page/k0728tn7sty.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=4" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=4</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP" target="_blank" rel="noopener">https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP</a></p><h2 id="5-生成-start-方法"><a href="#5-生成-start-方法" class="headerlink" title="5. 生成 start 方法"></a>5. 生成 start 方法</h2><p>这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/x0728j7j7a6.html" target="_blank" rel="noopener">https://v.qq.com/x/page/x0728j7j7a6.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=5" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=5</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5" target="_blank" rel="noopener">https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5</a></p><h2 id="6-生成注入和状态保存的方法"><a href="#6-生成注入和状态保存的方法" class="headerlink" title="6. 生成注入和状态保存的方法"></a>6. 生成注入和状态保存的方法</h2><p>这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/d0728uitqdr.html" target="_blank" rel="noopener">https://v.qq.com/x/page/d0728uitqdr.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=6" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=6</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6" target="_blank" rel="noopener">https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6</a></p><h2 id="7-生成-Kotlin-代码"><a href="#7-生成-Kotlin-代码" class="headerlink" title="7. 生成 Kotlin 代码"></a>7. 生成 Kotlin 代码</h2><p>这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728y2inrf.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728y2inrf.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=7" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=7</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7</a></p><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><p>这一节对整个课程作了一个总结。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/m072848g85p.html" target="_blank" rel="noopener">https://v.qq.com/x/page/m072848g85p.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=8</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8</a></p><hr><p>欢迎关注 Kotlin 公众号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在做 &lt;a href=&quot;https://coding.imooc.com/class/232.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计&lt;/a&gt; 这门课的时候，顺便做了一个注解处理器的框架，叫 &lt;a href=&quot;https://github.com/enbandari/TieGuanYin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tieguanyin(铁观音)&lt;/a&gt;，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 &lt;code&gt;Intent&lt;/code&gt; 来传递，有了这个框架我们就可以省去这个麻烦的步骤。&lt;/p&gt;&lt;p&gt;在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 社区资源介绍</title>
    <link href="https://www.bennyhuo.com/2018/10/02/kotlin-community-cn/"/>
    <id>https://www.bennyhuo.com/2018/10/02/kotlin-community-cn/</id>
    <published>2018-10-02T02:42:38.566Z</published>
    <updated>2019-04-06T01:23:19.972Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。</p><a id="more"></a><ol><li><strong><a href="https://www.kotlincn.net" target="_blank" rel="noopener">Kotlin 中文官网</a></strong>，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。</li><li><strong><a href="https://www.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文博客</a></strong>，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。</li><li><strong><a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文论坛</a></strong>，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。</li><li><strong>微信公众号 Kotlin</strong>，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。</li></ol><p>欢迎关注 Kotlin 公众号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
