<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennyhuo</title>
  
  <subtitle>编程、教学 &amp; Kotlin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2018-12-16T23:17:56.543Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Bennyhuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</title>
    <link href="https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/"/>
    <id>https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/</id>
    <published>2018-12-16T23:12:05.412Z</published>
    <updated>2018-12-16T23:17:56.543Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 <code>CName</code> 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。</p><p>后来，我发现根本不需要这么麻烦啊。</p><a id="more"></a><p>我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java_包名_类名_方法名</span><br></pre></td></tr></table></figure><p>换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。</p><p>那么假如我们有下面的 Java 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJni</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们只要保证 so 库当中存在一个函数名为 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 并且返回 <code>jstring</code> 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。</p><p>我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">kotlin &#123;</span><br><span class="line">    targets &#123;</span><br><span class="line">        fromPreset(presets.androidNativeArm32, <span class="string">'HelloWorld'</span>) <span class="comment">// ① 配置为 Android 的工程</span></span><br><span class="line"></span><br><span class="line">        configure([HelloWorld]) &#123;</span><br><span class="line">            compilations.main.outputKinds <span class="string">'DYNAMIC'</span> <span class="comment">// ② 配置为动态链接库</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后随便创建一个文件，写一个全局函数，并用 <code>CName</code> 进行标注如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.cinterop.*</span><br><span class="line"><span class="keyword">import</span> platform.android.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_stringFromJNI"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">return</span> env.pointed.pointed!!.NewStringUTF!!.invoke(env, <span class="string">"This is from Kotlin Native!!"</span>.cstr.ptr)!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 <code>jstring</code> 这样的类型。</p><p>然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"knlib"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行时就可以调用 <code>stringFromJNI</code> 这个方法啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = (TextView)findViewById(R.id.hello_textview);</span><br><span class="line">tv.setText(stringFromJNI());</span><br></pre></td></tr></table></figure><p>接下来我再给大家看几个例子：</p><p>首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_sayHello"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"Hello %s"</span>, <span class="string">"Native"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在 Kotlin Native 当中调用 Java 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_callLoop"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLoop</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> jniEnvVal = env.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)</span><br><span class="line">        <span class="keyword">val</span> methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, <span class="string">"callFromNative"</span>.cstr.ptr, <span class="string">"()Ljava/lang/String;"</span>.cstr.ptr)</span><br><span class="line">        <span class="keyword">return</span> jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, <span class="literal">null</span>) <span class="keyword">as</span> jstring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>callFromNative</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callFromNative</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is from Java!!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。</p><p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a></p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 &lt;code&gt;CName&lt;/code&gt; 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。&lt;/p&gt;&lt;p&gt;后来，我发现根本不需要这么麻烦啊。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>也许你需要这个为数据类生成 DeepCopy 方法的库</title>
    <link href="https://www.bennyhuo.com/2018/12/02/deepcopy/"/>
    <id>https://www.bennyhuo.com/2018/12/02/deepcopy/</id>
    <published>2018-12-02T12:42:55.050Z</published>
    <updated>2018-12-02T12:45:27.236Z</updated>
    
    <content type="html"><![CDATA[<p>前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。</p><a id="more"></a><h2 id="我们有什么拷贝的需求？"><a href="#我们有什么拷贝的需求？" class="headerlink" title="我们有什么拷贝的需求？"></a>我们有什么拷贝的需求？</h2><p>我们知道 Kotlin 的 data class 出厂自带了一套 <code>copy</code> 方法，这个 <code>copy</code> 方法呢，就是实打实的一个浅拷贝，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>它的 <code>copy</code> 方法其实就相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name)</span></span> = GitUser(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成员是 <code>val</code> 那倒也还好，可如果是另一个数据类呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>我们如果需要 <code>copy</code> 一下 <code>Owner</code> 的话，我们就会发现新实例与旧实例共享了 <code>GitUser</code> 和 <code>Project</code> 的实例，万一项目的名称是可以改的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">var</span> name: String)</span><br></pre></td></tr></table></figure><p>新实例的 <code>project</code> 的名称我想更改一下，结果发现老实例的也被改了。</p><p>所以你需要一个 DeepCopy 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner &#123;</span><br><span class="line">        <span class="keyword">return</span> Owner(gitUser.copy(), project.copy())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你这时候想，虽然 <code>GitUser</code> 和 <code>Project</code> 这两个数据类内部的字段都是基本类型，用 <code>copy</code> 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 <code>deepCopy</code> 方法。。。</p><h2 id="来来来，先实现个简单的"><a href="#来来来，先实现个简单的" class="headerlink" title="来来来，先实现个简单的"></a>来来来，先实现个简单的</h2><p>天哪。那岂不是要写死了。</p><p>不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ</p><p>于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 <code>deepCopy</code> 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> T.<span class="title">deepCopy</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="comment">//①判断是否为数据类，不是的话直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">isData</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">primaryConstructor</span>!!.<span class="title">let</span> </span>&#123; primaryConstructor -&gt;</span><br><span class="line">        primaryConstructor.parameters</span><br><span class="line">            .map &#123; parameter -&gt;</span><br><span class="line">                <span class="keyword">val</span> value =</span><br><span class="line">                    (<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span> <span class="title">as</span> <span class="title">KClass</span>&lt;<span class="type">T</span>&gt;).<span class="title">declaredMemberProperties</span>.<span class="title">first</span> </span>&#123; it.name == parameter.name &#125;.<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">                <span class="comment">//③如果主构造器参数类型为数据类，递归调用</span></span><br><span class="line">                <span class="keyword">if</span> ((parameter.type.classifier <span class="keyword">as</span>? KClass&lt;*&gt;)?.isData == <span class="literal">true</span>) &#123;</span><br><span class="line">                    parameter to value?.deepCopy()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parameter to value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toMap()</span><br><span class="line">            .let(primaryConstructor::callBy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~*</p><p>其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻</p><p>这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-reflect:1.1.0'</span></span><br></pre></td></tr></table></figure><p>当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——</p><h2 id="来我们再试试注解处理器"><a href="#来我们再试试注解处理器" class="headerlink" title="来我们再试试注解处理器"></a>来我们再试试注解处理器</h2><p>注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。</p><p>不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 <code>Metadata</code> 来获取到这些信息。</p><p>读取 <code>Metadata</code> 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4"</span></span><br></pre></td></tr></table></figure><p>读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ</p><p>需要提一句的是，我们通过注解处理器生成的 <code>deepCopy</code> 可以添加默认参数，这里有不少细节需要处理，也是得益于 <code>Metadata</code> 的信息。</p><p>下面给大家看看例子吧：</p><p>首先添加依赖，配置注解处理器：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    <span class="comment">//kotlinx-metadata-jvm 目前部署到了这个仓库</span></span><br><span class="line">    maven &#123; url <span class="string">"https://kotlin.bintray.com/kotlinx/"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">apply plugin: <span class="string">"kotlin-kapt"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    kapt <span class="string">'com.bennyhuo.kotlin:deepcopy-compiler:1.1.0'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-annotations:1.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着为我们的数据类配置注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>build 一下，生成了下面的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner =</span><br><span class="line">    Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>我们看到，这已经跟出厂自带的 <code>copy</code> 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 <code>DeepCopy</code>，如果标注，就递归调用对应的 <code>deepCopy</code> 函数。</p><p>其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">()</span></span>: Owner = Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameter</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, List&lt;String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameterT</span>&lt;<span class="type">K: Number, V</span>&gt;</span>(<span class="keyword">val</span> map: HashMap&lt;K, V&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StarProjection</span></span>(<span class="keyword">val</span> map: List&lt;Map&lt;*, String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Variances1</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, <span class="keyword">out</span> List&lt;Number&gt;&gt;)</span><br></pre></td></tr></table></figure><p>如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。</p><h2 id="项目详情"><a href="#项目详情" class="headerlink" title="项目详情"></a>项目详情</h2><p>这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：<a href="https://github.com/enbandari/KotlinDeepCopy" target="_blank" rel="noopener">https://github.com/enbandari/KotlinDeepCopy</a>，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。</p><p>别犹豫了，Star 一波吧，千万别手软。</p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReleasableVar，可以为空的 Kotlin 非空类型 var</title>
    <link href="https://www.bennyhuo.com/2018/11/26/ReleasableVar/"/>
    <id>https://www.bennyhuo.com/2018/11/26/ReleasableVar/</id>
    <published>2018-11-25T23:28:47.024Z</published>
    <updated>2018-11-25T23:31:00.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-题外话：Hadi-的插件"><a href="#0-题外话：Hadi-的插件" class="headerlink" title="0. 题外话：Hadi 的插件"></a>0. 题外话：Hadi 的插件</h1><p>上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：</p><ul><li>Nyan Process Bar</li><li>Presentation Assistant</li></ul><p>也有同学问我ppt的，上周一的文章末尾有提供哈~</p><p>好了下面我们言归正传~</p><h1 id="1-描述下需求"><a href="#1-描述下需求" class="headerlink" title="1. 描述下需求"></a>1. 描述下需求</h1><p>前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 <code>null</code>，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// You cannot do that!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>你想着 Activity 的 <code>onStop</code> 调用了之后到被回收还得等一会儿呢，甚至 <code>onDestroy</code> 都会过一会儿才会被执行到，所以 <code>image</code> 可能会在内存被持有一段时间。所以幸好我们可以通过 <code>recycle</code> 方法先告诉 <code>Bitmap</code> 该释放内存了，不然的话我们只能等着 <code>Activity</code> 回收的时候 <code>image</code> 引用的对象才可以回收。</p><p>不可空类型能够置为 <code>null</code> 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。</p><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><p>想来想去，这个只能官方提供一个方法了，就像 <code>lateinitVar::isInitialized</code> 一样，提供一个 <code>lateinitVar::release()</code> 然后把 backingfield 的值给清空了不就好了吗？</p><p>这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Not Initialized or released already."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用的时候也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar <span class="keyword">by</span> releasableNotNull&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 <code>lateinit</code> 定义一个判断是否初始化的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.isInitialized()</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-干掉反射"><a href="#3-干掉反射" class="headerlink" title="3. 干掉反射"></a>3. 干掉反射</h1><p>然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 <code>null</code>，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。</p><p>其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 <code>KProperty0</code> 的 <code>receiver</code> 拿到属性代理对象了，所以我们需要的只是一个<code>WeakHashMap</code>，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 <code>WeakIdentityMap</code> 的集合，对应于有弱引用功能的 <code>IdentityHashMap</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> releasableRefs: WeakIdentityMap&lt;Any, MutableMap&lt;String, ReleasableNotNull&lt;*&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>那么我们只需要在前面的 <code>setValue</code> 当中绑定他们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> map = releasableRefs[thisRef]</span><br><span class="line">            <span class="keyword">if</span>(map == <span class="literal">null</span>)&#123;</span><br><span class="line">                map = HashMap()</span><br><span class="line">                releasableRefs[thisRef] = map</span><br><span class="line">            &#125;</span><br><span class="line">            map[property.name] = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>Map 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">            releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.isInitialized()</span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">        releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-怎么用？"><a href="#4-怎么用？" class="headerlink" title="4. 怎么用？"></a>4. 怎么用？</h1><p>啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 <code>KProperty0</code> 是啥，它其实就是一个顶级变量或者已经绑定完 <code>receiver</code> 的变量，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varInPackage = <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">"World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性我们通过下面的属性引用得到的就是 <code>KProperty0</code> 的实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::varInPackage</span><br><span class="line"></span><br><span class="line">Foo()::bar</span><br></pre></td></tr></table></figure><p>换句话说，我们开头给出的那个 <code>image</code> 的例子就可以这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        image.recycle()</span><br><span class="line">        ::image.release() <span class="comment">// You simply make the backing value null, thus making the gc of this Bitmap instance possible. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-你想直接用？"><a href="#5-你想直接用？" class="headerlink" title="5. 你想直接用？"></a>5. 你想直接用？</h1><p>我已经把这东西扔到 jCenter了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0&quot;</span><br></pre></td></tr></table></figure><p>完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：</p><p><a href="https://github.com/enbandari/ReleasableVar" target="_blank" rel="noopener">https://github.com/enbandari/ReleasableVar</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-题外话：Hadi-的插件&quot;&gt;&lt;a href=&quot;#0-题外话：Hadi-的插件&quot; class=&quot;headerlink&quot; title=&quot;0. 题外话：Hadi 的插件&quot;&gt;&lt;/a&gt;0. 题外话：Hadi 的插件&lt;/h1&gt;&lt;p&gt;上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nyan Process Bar&lt;/li&gt;&lt;li&gt;Presentation Assistant&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也有同学问我ppt的，上周一的文章末尾有提供哈~&lt;/p&gt;&lt;p&gt;好了下面我们言归正传~&lt;/p&gt;&lt;h1 id=&quot;1-描述下需求&quot;&gt;&lt;a href=&quot;#1-描述下需求&quot; class=&quot;headerlink&quot; title=&quot;1. 描述下需求&quot;&gt;&lt;/a&gt;1. 描述下需求&lt;/h1&gt;&lt;p&gt;前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 &lt;code&gt;null&lt;/code&gt;，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Activity &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; image: Bitmap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStart()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = Bitmap.create(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image.recycle()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// You cannot do that!!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018 JetBrains 开发者大会见闻</title>
    <link href="https://www.bennyhuo.com/2018/11/18/2018-JetBrains-Day/"/>
    <id>https://www.bennyhuo.com/2018/11/18/2018-JetBrains-Day/</id>
    <published>2018-11-18T06:23:04.343Z</published>
    <updated>2018-11-18T22:39:53.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。</p></blockquote><p>话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg" alt=""></p><a id="more"></a><p>大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。</p><p>开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）</p><p>JetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg" alt=""></p><p>印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg" alt=""></p><p>还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。</p><p>干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a>）。</p><p>Hadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。</p><p>中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg" alt=""></p><p>因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||</p><p>讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T</p><p>整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。</p><p>Hadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg" alt=""></p><p>还有一个是 Nyan 进度条的插件，很有趣：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg" alt=""></p><p>来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: GitUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，现在我们也可以用 <code>Deferred</code> 来接入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: Deferred&lt;GitUser&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。</p><p>听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)</p><p>不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！</p><p>下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg" alt=""></p><p>这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~</p><p>PS：茶歇的小饼干也很好吃啊！</p><hr><p>下午第一场 “如何优雅地使用数据类” 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~</p><p>链接：<a href="https://share.weiyun.com/5YMPoL4" target="_blank" rel="noopener">https://share.weiyun.com/5YMPoL4</a> 密码：sz4vyw</p><hr><p>Kotlin 中文站：<a href="https://www.kotlincn.net" target="_blank" rel="noopener">https://www.kotlincn.net</a><br>Kotlin 中文博客：<a href="https://www.kotliner.cn" target="_blank" rel="noopener">https://www.kotliner.cn</a><br>Kotlin 中文论坛：<a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">https://discuss.kotliner.cn</a><br>Ktor 中文站：<a href="https://ktor.kotlincn.net" target="_blank" rel="noopener">https://ktor.kotlincn.net</a></p><hr><p>欢迎关注：微信公众号 Kotlin</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>注解处理器教程[全]</title>
    <link href="https://www.bennyhuo.com/2018/10/03/apt-tutorials/"/>
    <id>https://www.bennyhuo.com/2018/10/03/apt-tutorials/</id>
    <published>2018-10-03T02:06:48.914Z</published>
    <updated>2018-11-18T10:24:49.315Z</updated>
    
    <content type="html"><![CDATA[<p>我在做 <a href="https://coding.imooc.com/class/232.html" target="_blank" rel="noopener">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a> 这门课的时候，顺便做了一个注解处理器的框架，叫 <a href="https://github.com/enbandari/TieGuanYin" target="_blank" rel="noopener">Tieguanyin(铁观音)</a>，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 <code>Intent</code> 来传递，有了这个框架我们就可以省去这个麻烦的步骤。</p><p>在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。</p><a id="more"></a><h1 id="视频源码"><a href="#视频源码" class="headerlink" title="视频源码"></a>视频源码</h1><p>见 Github 项目：<a href="https://github.com/enbandari/Apt-Tutorials" target="_blank" rel="noopener">Apt-Tutorials</a></p><h1 id="视频观看"><a href="#视频观看" class="headerlink" title="视频观看"></a>视频观看</h1><h2 id="1-课程简介"><a href="#1-课程简介" class="headerlink" title="1. 课程简介"></a>1. 课程简介</h2><p>作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728uxh61x.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728uxh61x.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=1</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1</a></p><h2 id="2-搭建工程"><a href="#2-搭建工程" class="headerlink" title="2. 搭建工程"></a>2. 搭建工程</h2><p>这一节主要介绍注解处理器工程的结构。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/o07284u5rju.html" target="_blank" rel="noopener">https://v.qq.com/x/page/o07284u5rju.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=2</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2" target="_blank" rel="noopener">https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2</a></p><h2 id="3-解析注解"><a href="#3-解析注解" class="headerlink" title="3. 解析注解"></a>3. 解析注解</h2><p>这一节主要介绍如何解析注解获取被标注的元素信息。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/z07286r97mz.html" target="_blank" rel="noopener">https://v.qq.com/x/page/z07286r97mz.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=3</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3</a></p><h2 id="4-生成常量"><a href="#4-生成常量" class="headerlink" title="4. 生成常量"></a>4. 生成常量</h2><p>这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/k0728tn7sty.html" target="_blank" rel="noopener">https://v.qq.com/x/page/k0728tn7sty.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=4" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=4</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP" target="_blank" rel="noopener">https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP</a></p><h2 id="5-生成-start-方法"><a href="#5-生成-start-方法" class="headerlink" title="5. 生成 start 方法"></a>5. 生成 start 方法</h2><p>这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/x0728j7j7a6.html" target="_blank" rel="noopener">https://v.qq.com/x/page/x0728j7j7a6.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=5" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=5</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5" target="_blank" rel="noopener">https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5</a></p><h2 id="6-生成注入和状态保存的方法"><a href="#6-生成注入和状态保存的方法" class="headerlink" title="6. 生成注入和状态保存的方法"></a>6. 生成注入和状态保存的方法</h2><p>这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/d0728uitqdr.html" target="_blank" rel="noopener">https://v.qq.com/x/page/d0728uitqdr.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=6" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=6</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6" target="_blank" rel="noopener">https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6</a></p><h2 id="7-生成-Kotlin-代码"><a href="#7-生成-Kotlin-代码" class="headerlink" title="7. 生成 Kotlin 代码"></a>7. 生成 Kotlin 代码</h2><p>这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728y2inrf.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728y2inrf.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=7" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=7</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7</a></p><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><p>这一节对整个课程作了一个总结。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/m072848g85p.html" target="_blank" rel="noopener">https://v.qq.com/x/page/m072848g85p.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=8</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8</a></p><hr><p>欢迎关注 Kotlin 公众号：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在做 &lt;a href=&quot;https://coding.imooc.com/class/232.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计&lt;/a&gt; 这门课的时候，顺便做了一个注解处理器的框架，叫 &lt;a href=&quot;https://github.com/enbandari/TieGuanYin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tieguanyin(铁观音)&lt;/a&gt;，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 &lt;code&gt;Intent&lt;/code&gt; 来传递，有了这个框架我们就可以省去这个麻烦的步骤。&lt;/p&gt;&lt;p&gt;在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 社区资源介绍</title>
    <link href="https://www.bennyhuo.com/2018/10/02/kotlin-community-cn/"/>
    <id>https://www.bennyhuo.com/2018/10/02/kotlin-community-cn/</id>
    <published>2018-10-02T02:42:38.566Z</published>
    <updated>2018-11-18T10:24:49.314Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。</p><a id="more"></a><ol><li><strong><a href="https://www.kotlincn.net" target="_blank" rel="noopener">Kotlin 中文官网</a></strong>，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。</li><li><strong><a href="https://www.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文博客</a></strong>，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。</li><li><strong><a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文论坛</a></strong>，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。</li><li><strong>微信公众号 Kotlin</strong>，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。</li></ol><p>欢迎关注 Kotlin 公众号：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
