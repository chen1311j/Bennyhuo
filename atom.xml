<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennyhuo</title>
  
  <subtitle>编程、教学 &amp; Kotlin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2019-03-10T22:51:56.423Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Bennyhuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 Node.js 环境的 KotlinJs 工程的完美搭建</title>
    <link href="https://www.bennyhuo.com/2019/03/11/kotlin-nodejs/"/>
    <id>https://www.bennyhuo.com/2019/03/11/kotlin-nodejs/</id>
    <published>2019-03-10T22:51:20.136Z</published>
    <updated>2019-03-10T22:51:56.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要这样一篇文章"><a href="#为什么需要这样一篇文章" class="headerlink" title="为什么需要这样一篇文章"></a>为什么需要这样一篇文章</h3><p>我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。</p><p>而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。</p><p>这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：</p><ul><li>依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装</li><li>右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样</li><li>单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知</li></ul><p>基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。</p><p>接着，你需要在 IU 中安装 NodeJS 插件，如图：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg" alt=""></p><p>我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。</p><p>最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg" alt=""></p><p>工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg" alt=""></p><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg" alt=""></p><p>点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg" alt=""></p><p>首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。</p><p>当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs 编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compileKotlin2Js &#123;</span><br><span class="line">    kotlinOptions.moduleKind = <span class="string">'commonjs'</span></span><br><span class="line">    kotlinOptions.sourceMap = <span class="literal">true</span></span><br><span class="line">    kotlinOptions.metaInfo = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。</p><p>这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 <code>require(&#39;kotlin&#39;)</code>，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-js"</span></span><br><span class="line">    testImplementation <span class="string">"org.jetbrains.kotlin:kotlin-test-js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这怎么能运行得起来呢？</p><p>因此我们还需要一个插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.jetbrains.kotlin.frontend'</span></span><br></pre></td></tr></table></figure><p>为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">"https://dl.bintray.com/kotlin/kotlin-eap"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg" alt=""></p><p>而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kotlinFrontend &#123;</span><br><span class="line">    npm &#123;</span><br><span class="line">        dependency <span class="string">"style-loader"</span> <span class="comment">// production dependency</span></span><br><span class="line">        devDependency <span class="string">"karma"</span>     <span class="comment">// development dependency</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还支持 webpack 。</p><p>好啦，这时候再运行咱们的程序，就会得到结果：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg" alt=""></p><h2 id="体验一把-KotlinJs-的协程"><a href="#体验一把-KotlinJs-的协程" class="headerlink" title="体验一把 KotlinJs 的协程"></a>体验一把 KotlinJs 的协程</h2><p>首先添加依赖：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1'</span></span><br></pre></td></tr></table></figure><p>接着，编写我们的 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"[<span class="subst">$&#123;Date().toLocaleTimeString()&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">val</span> result = withContext(coroutineContext) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">4</span>)</span><br><span class="line">            <span class="string">"HelloWorld"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">"5. <span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg" alt=""></p><p>单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg" alt=""></p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg" alt=""></p><p>我们可以看到 result 的值正是协程内部返回的 HelloWorld。</p><p>是不是很美？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑&gt;◡&lt;๑)۶</p><blockquote><p>从此，小伙伴们与 KotlinJs 过上了幸福的生活~</p></blockquote><hr><ul><li>Bennyhuo 所在的组招 Android 实习生</li><li>腾讯地图相关业务，坐标 <strong>北京中关村</strong></li><li>暑期实习、日常实习都可以考虑</li><li>有兴趣的小伙伴可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a> 哈~</li></ul><hr><p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>长按识别二维码即可进入课程啦！</strong></p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么需要这样一篇文章&quot;&gt;&lt;a href=&quot;#为什么需要这样一篇文章&quot; class=&quot;headerlink&quot; title=&quot;为什么需要这样一篇文章&quot;&gt;&lt;/a&gt;为什么需要这样一篇文章&lt;/h3&gt;&lt;p&gt;我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。&lt;/p&gt;&lt;p&gt;而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。&lt;/p&gt;&lt;p&gt;这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装&lt;/li&gt;&lt;li&gt;右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样&lt;/li&gt;&lt;li&gt;单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>父类返回子类类型的函数写法</title>
    <link href="https://www.bennyhuo.com/2019/02/18/this-type/"/>
    <id>https://www.bennyhuo.com/2019/02/18/this-type/</id>
    <published>2019-02-18T04:38:06.021Z</published>
    <updated>2019-02-18T04:41:28.518Z</updated>
    
    <content type="html"><![CDATA[<p>今天的话题很简单，分享下也许对大家可以有帮助或者有启发。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>一看题目，有点儿晕。看个例子马上就明白了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBuilder</span></span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: EventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableEventBuilder</span> : <span class="type">EventBuilder</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="built_in">Long</span> = <span class="number">0</span>L</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(delay: <span class="type">Long</span>)</span></span>: DisposableEventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = <span class="keyword">object</span>: DisposableEvent(name, delay)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDisposableEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">            callback.onEvent(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去也没啥大毛病，用一下吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60</span>_000) <span class="comment">// ERROR!! </span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>我们调用完父类的 <code>retryLimit</code> 方法后，想要设置下 <code>delay</code>，结果发现没有这个方法。</p><blockquote><p>“我 X，这什么玩意儿”，你嘟囔了一句。</p></blockquote><a id="more"></a><p>因为返回的是父类，所以链式调用掉链子了。这就尴尬了。</p><h2 id="2-Scala-的解法"><a href="#2-Scala-的解法" class="headerlink" title="2. Scala 的解法"></a>2. Scala 的解法</h2><p>如果这段代码用 Scala 写，那么用 <code>this.type</code> 就简直完美的解决了这个问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> retryLimit: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retryLimit</span></span>(retryLimit: <span class="type">Int</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBuilder</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delay</span></span>(delay: <span class="type">Long</span>): <span class="type">SubBuilder</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">SubBuilder</span>().retryLimit(<span class="number">3</span>).delay(<span class="number">60000</span>)</span><br></pre></td></tr></table></figure><p>一点儿毛病都么有。</p><p>Kotlin 有这个特性吗？并没有。</p><h2 id="3-Kotlin-的解法"><a href="#3-Kotlin-的解法" class="headerlink" title="3. Kotlin 的解法"></a>3. Kotlin 的解法</h2><p>Kotlin 倒也不是没有办法解决这个问题，用下泛型就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBuilder</span>&lt;<span class="type">T : EventBuilder&lt;T</span>&gt;&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。</p><p>子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableEventBuilder</span> : <span class="type">EventBuilder</span>&lt;<span class="type">DisposableEventBuilder</span>&gt;</span>() &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的什么也不用动，这时候我们的链式调用就没啥问题了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60</span>_000) <span class="comment">// OK!!</span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperBuilder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> retryLimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">retryLimit</span><span class="params">(<span class="keyword">int</span> retryLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBuilder</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span>&lt;<span class="title">SubBuilder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SuperBuilder <span class="title">delay</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，今天就先这样~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的话题很简单，分享下也许对大家可以有帮助或者有启发。&lt;/p&gt;&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;一看题目，有点儿晕。看个例子马上就明白了：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EventBuilder&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; retryLimit = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;retryLimit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(retryLimit: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: EventBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.retryLimit = retryLimit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: PollingEvent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DisposableEventBuilder&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;EventBuilder&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; delay: &lt;span class=&quot;built_in&quot;&gt;Long&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(delay: &lt;span class=&quot;type&quot;&gt;Long&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: DisposableEventBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.delay = delay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;: DisposableEvent(name, delay)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDisposableEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            callback.onEvent(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;看上去也没啥大毛病，用一下吧：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DisposableEventBuilder().retryLimit(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .delay(&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;_000) &lt;span class=&quot;comment&quot;&gt;// ERROR!! &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们调用完父类的 &lt;code&gt;retryLimit&lt;/code&gt; 方法后，想要设置下 &lt;code&gt;delay&lt;/code&gt;，结果发现没有这个方法。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“我 X，这什么玩意儿”，你嘟囔了一句。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新年 Flag 以及论坛的一个所谓“Kotlin 不完全兼容 Java”的问题</title>
    <link href="https://www.bennyhuo.com/2019/02/05/2019-02-05/"/>
    <id>https://www.bennyhuo.com/2019/02/05/2019-02-05/</id>
    <published>2019-02-04T22:31:49.632Z</published>
    <updated>2019-02-18T04:44:42.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-新年立个-Flag"><a href="#0-新年立个-Flag" class="headerlink" title="0. 新年立个 Flag"></a>0. 新年立个 Flag</h3><p>首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。</p><p>每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。</p><p>我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。</p><a id="more"></a><p>一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。</p><p>下面我们说我们今天的正题：</p><h3 id="1-Kotlin-不能完全兼容-Java-吗？"><a href="#1-Kotlin-不能完全兼容-Java-吗？" class="headerlink" title="1. Kotlin 不能完全兼容 Java 吗？"></a>1. Kotlin 不能完全兼容 Java 吗？</h3><p>有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：</p><hr><p><strong>原帖开始</strong></p><p>Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，<br>但是在实际使用上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">    <span class="keyword">public</span> String mmm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiException</span><span class="params">(Throwable throwable, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(throwable);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> detailMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exception = ApiException(Throwable(),<span class="number">1</span>)</span><br><span class="line">exception.code <span class="comment">//正常</span></span><br><span class="line">exception.message <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure><p>错误信息如下：</p><blockquote><p>Overload resolution ambiguity. All these functions match. public final var message</p></blockquote><p>java中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ApiException(Throwable(),<span class="number">1</span>).message 完全正常</span><br></pre></td></tr></table></figure><p>java 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。</p><p><strong>原帖结束</strong></p><hr><p>看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。</p><p>题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？</p><p>当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）</p><p>好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：</p><p>先用 Java 包装一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtApiException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(ApiException a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在 Kotlin 里面这样调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = ApiException()</span><br><span class="line"><span class="keyword">val</span> t = (a <span class="keyword">as</span> Throwable).message</span><br><span class="line"><span class="keyword">val</span> r = ExtApiException.getMessage(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ApiException.<span class="title">realMessage</span><span class="params">()</span></span> = ExtApiException.getMessage(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">val</span> i = a.realMessage()</span><br></pre></td></tr></table></figure><p>这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。</p><h3 id="2-为什么-message-会和-getMessage-纠缠不清？"><a href="#2-为什么-message-会和-getMessage-纠缠不清？" class="headerlink" title="2. 为什么 message 会和 getMessage 纠缠不清？"></a>2. 为什么 message 会和 getMessage 纠缠不清？</h3><p>这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwable</span> <span class="keyword">public</span> <span class="keyword">constructor</span></span>(message: kotlin.String?, cause: kotlin.Throwable?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> message: kotlin.String? </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。</p><h3 id="3-真的没有办法通过-Kotlin-实现访问吗？"><a href="#3-真的没有办法通过-Kotlin-实现访问吗？" class="headerlink" title="3. 真的没有办法通过 Kotlin 实现访问吗？"></a>3. 真的没有办法通过 Kotlin 实现访问吗？</h3><p>Kotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exception = ApiException(Throwable(<span class="string">"ThrowableMessage"</span>),<span class="number">1</span>)</span><br><span class="line">println((exception <span class="keyword">as</span> java.lang.Throwable).getMessage())</span><br></pre></td></tr></table></figure><p>不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">property1</span><span class="params">(property: <span class="type">KProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">mutableProperty1</span><span class="params">(property: <span class="type">KMutableProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ApiException.throwableMessage: String?</span><br><span class="line">        <span class="keyword">get</span>() = property1(Throwable::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ApiException.apiMessage</span><br><span class="line">    <span class="keyword">get</span>() = mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">set</span>(<span class="keyword">this</span>, value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。</p><p>当然我们也可以通过是否可空来区分，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ApiException.apiMessage2: String</span><br><span class="line">    <span class="keyword">get</span>() = property1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>我们如果给 property1 的第二个泛型参数传入 <code>String</code> 而不是 <code>String?</code> 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。</p><p>这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloKt</span>$<span class="title">apiMessage</span>$2 <span class="keyword">extends</span> <span class="title">MutablePropertyReference1</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KMutableProperty1 INSTANCE = <span class="keyword">new</span> HelloKt$apiMessage$<span class="number">2</span>();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"message"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getSignature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"getMessage()Ljava/lang/String;"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> KDeclarationContainer <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Reflection.getOrCreateKotlinClass(ApiException.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(@Nullable Object receiver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ((ApiException)receiver).message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@Nullable Object receiver, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">      ((ApiException)receiver).message = (String)value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。</p><p>当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-新年立个-Flag&quot;&gt;&lt;a href=&quot;#0-新年立个-Flag&quot; class=&quot;headerlink&quot; title=&quot;0. 新年立个 Flag&quot;&gt;&lt;/a&gt;0. 新年立个 Flag&lt;/h3&gt;&lt;p&gt;首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。&lt;/p&gt;&lt;p&gt;每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。&lt;/p&gt;&lt;p&gt;我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 协程版的 AutoDispose</title>
    <link href="https://www.bennyhuo.com/2019/01/07/2019-01-07/"/>
    <id>https://www.bennyhuo.com/2019/01/07/2019-01-07/</id>
    <published>2019-01-07T04:19:27.797Z</published>
    <updated>2019-01-07T04:20:19.827Z</updated>
    
    <content type="html"><![CDATA[<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p><p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose" target="_blank" rel="noopener">AutoDispose</a>。</p><a id="more"></a><p>什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.view = view;</span><br><span class="line">    <span class="keyword">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我最近在想我们用协程其实也会有这样的问题呀：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClick &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>await</code> 返回结果之前我们就退出了当前的 <code>Activity</code> 那么，后面 <code>updateUI</code> 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 <code>onClickAutoDisposable</code> 嘛。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">android</span>.<span class="type">view</span>.<span class="type">View</span>?)</span></span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，不要脸的先抄 Anko 的 <code>onClick</code>，不同之处在于我们改了个名 XD。啊，还有我们加了个 <code>.asAutoDisposable(v)</code>，大家就假装有这个方法吧。。。</p><blockquote><p>(╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。</p></blockquote><p>OK OK，咱们下面来实现它。。想想，<code>GlobalScope.launch</code> 其实返回的是一个 <code>Job</code>，所以嘛，我们给 <code>Job</code> 搞一个扩展方法不就得了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>第二步，我们再偷偷的创建一个类，叫 <code>AutoDisposableJob</code>，抄一下前面的 <code>Listener</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoDisposableJob</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以使用这个扩展了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。&lt;/p&gt;&lt;p&gt;因此大家一定会用到 Uber 的开源框架 &lt;a href=&quot;https://github.com/uber/AutoDispose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AutoDispose&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</title>
    <link href="https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/"/>
    <id>https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/</id>
    <published>2018-12-30T23:43:13.084Z</published>
    <updated>2018-12-30T23:46:29.830Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我讲了用 <code>@CName</code> 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。</p><a id="more"></a><p>如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"JNI_OnLoad"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">JNI_OnLoad</span><span class="params">(vm: <span class="type">CPointer</span>&lt;<span class="type">JavaVMVar</span>&gt;, preserved: <span class="type">COpaquePointer</span>)</span></span>: jint &#123;</span><br><span class="line">    <span class="keyword">return</span> memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"JNI_OnLoad"</span>)</span><br><span class="line">        <span class="keyword">if</span>(result == JNI_OK)&#123;</span><br><span class="line">            <span class="keyword">val</span> env = envStorage.pointed!!.pointed!!</span><br><span class="line">            <span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">"com/example/hellojni/HelloJni"</span>.cstr.ptr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">            jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">            jniMethod[<span class="number">0</span>].name = <span class="string">"sayHello2"</span>.cstr.ptr</span><br><span class="line">            jniMethod[<span class="number">0</span>].signature = <span class="string">"()V"</span>.cstr.ptr</span><br><span class="line">            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"register say hello2, %d, %d"</span>, sizeOf&lt;CPointerVar&lt;JNINativeMethod&gt;&gt;(), sizeOf&lt;JNINativeMethod&gt;())</span><br><span class="line">        &#125;</span><br><span class="line">        JNI_VERSION_1_6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是先通过 <code>CName</code> 注解搞定 <code>JNI_OnLoad</code> 函数，让 Java 虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。</p><p>再说下 <code>memScope</code> 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 <code>memScope</code> 来提醒 Kotlin Native 这些变量需要来统一管理。</p><p>获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br></pre></td></tr></table></figure><p>这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，<code>CPointer</code> 的左值类型会映射成 <code>CPointerVar</code>，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。</p><p>接下来我们看这句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br></pre></td></tr></table></figure><p>C 版本的定义 <code>JavaVM</code> 其实本身也是一个指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br></pre></td></tr></table></figure><p>因此两个 <code>pointed</code> 的调用相当于获取到了 <code>JNIInvokeInterface</code> 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 <code>JNIEnv</code> 的操作了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br></pre></td></tr></table></figure><p>再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 <code>!!</code> 的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。</p><p>接下来我们要实现动态绑定了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">"com/example/hellojni/HelloJni"</span>.cstr.ptr)</span><br><span class="line"><span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">jniMethod[<span class="number">0</span>].name = <span class="string">"sayHello2"</span>.cstr.ptr</span><br><span class="line">jniMethod[<span class="number">0</span>].signature = <span class="string">"()V"</span>.cstr.ptr</span><br><span class="line">env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。</p><p>问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">var</span> RegisterNatives: kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlinx.cinterop.CPointer&lt;platform.android.JNIEnvVar <span class="comment">/* = kotlinx.cinterop.CPointerVarOf&lt;platform.android.JNIEnv /* = kotlinx.cinterop.CPointer&lt;platform.android.JNINativeInterface&gt; */</span>&gt; */&gt;?, platform.android.jclass? <span class="comment">/* = kotlinx.cinterop.CPointer&lt;out kotlinx.cinterop.CPointed&gt;? */</span>, kotlinx.cinterop.CPointer&lt;platform.android.JNINativeMethod&gt;?, platform.android.jint <span class="comment">/* = kotlin.Int */</span>) -&gt; platform.android.jint <span class="comment">/* = kotlin.Int */</span>&gt;&gt;? <span class="comment">/* compiled code */</span></span><br></pre></td></tr></table></figure><p>这其实就是 <code>RegisterNatives</code> 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。</p><p>这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。</p><p>简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。</p><p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我讲了用 &lt;code&gt;@CName&lt;/code&gt; 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</title>
    <link href="https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/"/>
    <id>https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/</id>
    <published>2018-12-16T23:12:05.412Z</published>
    <updated>2018-12-16T23:17:56.543Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 <code>CName</code> 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。</p><p>后来，我发现根本不需要这么麻烦啊。</p><a id="more"></a><p>我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java_包名_类名_方法名</span><br></pre></td></tr></table></figure><p>换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。</p><p>那么假如我们有下面的 Java 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJni</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们只要保证 so 库当中存在一个函数名为 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 并且返回 <code>jstring</code> 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。</p><p>我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">kotlin &#123;</span><br><span class="line">    targets &#123;</span><br><span class="line">        fromPreset(presets.androidNativeArm32, <span class="string">'HelloWorld'</span>) <span class="comment">// ① 配置为 Android 的工程</span></span><br><span class="line"></span><br><span class="line">        configure([HelloWorld]) &#123;</span><br><span class="line">            compilations.main.outputKinds <span class="string">'DYNAMIC'</span> <span class="comment">// ② 配置为动态链接库</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后随便创建一个文件，写一个全局函数，并用 <code>CName</code> 进行标注如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.cinterop.*</span><br><span class="line"><span class="keyword">import</span> platform.android.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_stringFromJNI"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">return</span> env.pointed.pointed!!.NewStringUTF!!.invoke(env, <span class="string">"This is from Kotlin Native!!"</span>.cstr.ptr)!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 <code>jstring</code> 这样的类型。</p><p>然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"knlib"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行时就可以调用 <code>stringFromJNI</code> 这个方法啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = (TextView)findViewById(R.id.hello_textview);</span><br><span class="line">tv.setText(stringFromJNI());</span><br></pre></td></tr></table></figure><p>接下来我再给大家看几个例子：</p><p>首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_sayHello"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"Hello %s"</span>, <span class="string">"Native"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在 Kotlin Native 当中调用 Java 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_callLoop"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLoop</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> jniEnvVal = env.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)</span><br><span class="line">        <span class="keyword">val</span> methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, <span class="string">"callFromNative"</span>.cstr.ptr, <span class="string">"()Ljava/lang/String;"</span>.cstr.ptr)</span><br><span class="line">        <span class="keyword">return</span> jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, <span class="literal">null</span>) <span class="keyword">as</span> jstring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>callFromNative</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callFromNative</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is from Java!!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。</p><p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a></p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 &lt;code&gt;CName&lt;/code&gt; 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。&lt;/p&gt;&lt;p&gt;后来，我发现根本不需要这么麻烦啊。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>也许你需要这个为数据类生成 DeepCopy 方法的库</title>
    <link href="https://www.bennyhuo.com/2018/12/02/deepcopy/"/>
    <id>https://www.bennyhuo.com/2018/12/02/deepcopy/</id>
    <published>2018-12-02T12:42:55.050Z</published>
    <updated>2018-12-02T12:45:27.236Z</updated>
    
    <content type="html"><![CDATA[<p>前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。</p><a id="more"></a><h2 id="我们有什么拷贝的需求？"><a href="#我们有什么拷贝的需求？" class="headerlink" title="我们有什么拷贝的需求？"></a>我们有什么拷贝的需求？</h2><p>我们知道 Kotlin 的 data class 出厂自带了一套 <code>copy</code> 方法，这个 <code>copy</code> 方法呢，就是实打实的一个浅拷贝，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>它的 <code>copy</code> 方法其实就相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name)</span></span> = GitUser(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成员是 <code>val</code> 那倒也还好，可如果是另一个数据类呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>我们如果需要 <code>copy</code> 一下 <code>Owner</code> 的话，我们就会发现新实例与旧实例共享了 <code>GitUser</code> 和 <code>Project</code> 的实例，万一项目的名称是可以改的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">var</span> name: String)</span><br></pre></td></tr></table></figure><p>新实例的 <code>project</code> 的名称我想更改一下，结果发现老实例的也被改了。</p><p>所以你需要一个 DeepCopy 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner &#123;</span><br><span class="line">        <span class="keyword">return</span> Owner(gitUser.copy(), project.copy())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你这时候想，虽然 <code>GitUser</code> 和 <code>Project</code> 这两个数据类内部的字段都是基本类型，用 <code>copy</code> 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 <code>deepCopy</code> 方法。。。</p><h2 id="来来来，先实现个简单的"><a href="#来来来，先实现个简单的" class="headerlink" title="来来来，先实现个简单的"></a>来来来，先实现个简单的</h2><p>天哪。那岂不是要写死了。</p><p>不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ</p><p>于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 <code>deepCopy</code> 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> T.<span class="title">deepCopy</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="comment">//①判断是否为数据类，不是的话直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">isData</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">primaryConstructor</span>!!.<span class="title">let</span> </span>&#123; primaryConstructor -&gt;</span><br><span class="line">        primaryConstructor.parameters</span><br><span class="line">            .map &#123; parameter -&gt;</span><br><span class="line">                <span class="keyword">val</span> value =</span><br><span class="line">                    (<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span> <span class="title">as</span> <span class="title">KClass</span>&lt;<span class="type">T</span>&gt;).<span class="title">declaredMemberProperties</span>.<span class="title">first</span> </span>&#123; it.name == parameter.name &#125;.<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">                <span class="comment">//③如果主构造器参数类型为数据类，递归调用</span></span><br><span class="line">                <span class="keyword">if</span> ((parameter.type.classifier <span class="keyword">as</span>? KClass&lt;*&gt;)?.isData == <span class="literal">true</span>) &#123;</span><br><span class="line">                    parameter to value?.deepCopy()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parameter to value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toMap()</span><br><span class="line">            .let(primaryConstructor::callBy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~*</p><p>其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻</p><p>这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-reflect:1.1.0'</span></span><br></pre></td></tr></table></figure><p>当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——</p><h2 id="来我们再试试注解处理器"><a href="#来我们再试试注解处理器" class="headerlink" title="来我们再试试注解处理器"></a>来我们再试试注解处理器</h2><p>注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。</p><p>不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 <code>Metadata</code> 来获取到这些信息。</p><p>读取 <code>Metadata</code> 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4"</span></span><br></pre></td></tr></table></figure><p>读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ</p><p>需要提一句的是，我们通过注解处理器生成的 <code>deepCopy</code> 可以添加默认参数，这里有不少细节需要处理，也是得益于 <code>Metadata</code> 的信息。</p><p>下面给大家看看例子吧：</p><p>首先添加依赖，配置注解处理器：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    <span class="comment">//kotlinx-metadata-jvm 目前部署到了这个仓库</span></span><br><span class="line">    maven &#123; url <span class="string">"https://kotlin.bintray.com/kotlinx/"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">apply plugin: <span class="string">"kotlin-kapt"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    kapt <span class="string">'com.bennyhuo.kotlin:deepcopy-compiler:1.1.0'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-annotations:1.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着为我们的数据类配置注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>build 一下，生成了下面的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner =</span><br><span class="line">    Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>我们看到，这已经跟出厂自带的 <code>copy</code> 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 <code>DeepCopy</code>，如果标注，就递归调用对应的 <code>deepCopy</code> 函数。</p><p>其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">()</span></span>: Owner = Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameter</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, List&lt;String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameterT</span>&lt;<span class="type">K: Number, V</span>&gt;</span>(<span class="keyword">val</span> map: HashMap&lt;K, V&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StarProjection</span></span>(<span class="keyword">val</span> map: List&lt;Map&lt;*, String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Variances1</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, <span class="keyword">out</span> List&lt;Number&gt;&gt;)</span><br></pre></td></tr></table></figure><p>如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。</p><h2 id="项目详情"><a href="#项目详情" class="headerlink" title="项目详情"></a>项目详情</h2><p>这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：<a href="https://github.com/enbandari/KotlinDeepCopy" target="_blank" rel="noopener">https://github.com/enbandari/KotlinDeepCopy</a>，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。</p><p>别犹豫了，Star 一波吧，千万别手软。</p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReleasableVar，可以为空的 Kotlin 非空类型 var</title>
    <link href="https://www.bennyhuo.com/2018/11/26/ReleasableVar/"/>
    <id>https://www.bennyhuo.com/2018/11/26/ReleasableVar/</id>
    <published>2018-11-25T23:28:47.024Z</published>
    <updated>2018-11-25T23:31:00.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-题外话：Hadi-的插件"><a href="#0-题外话：Hadi-的插件" class="headerlink" title="0. 题外话：Hadi 的插件"></a>0. 题外话：Hadi 的插件</h1><p>上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：</p><ul><li>Nyan Process Bar</li><li>Presentation Assistant</li></ul><p>也有同学问我ppt的，上周一的文章末尾有提供哈~</p><p>好了下面我们言归正传~</p><h1 id="1-描述下需求"><a href="#1-描述下需求" class="headerlink" title="1. 描述下需求"></a>1. 描述下需求</h1><p>前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 <code>null</code>，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// You cannot do that!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>你想着 Activity 的 <code>onStop</code> 调用了之后到被回收还得等一会儿呢，甚至 <code>onDestroy</code> 都会过一会儿才会被执行到，所以 <code>image</code> 可能会在内存被持有一段时间。所以幸好我们可以通过 <code>recycle</code> 方法先告诉 <code>Bitmap</code> 该释放内存了，不然的话我们只能等着 <code>Activity</code> 回收的时候 <code>image</code> 引用的对象才可以回收。</p><p>不可空类型能够置为 <code>null</code> 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。</p><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><p>想来想去，这个只能官方提供一个方法了，就像 <code>lateinitVar::isInitialized</code> 一样，提供一个 <code>lateinitVar::release()</code> 然后把 backingfield 的值给清空了不就好了吗？</p><p>这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Not Initialized or released already."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用的时候也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar <span class="keyword">by</span> releasableNotNull&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 <code>lateinit</code> 定义一个判断是否初始化的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.isInitialized()</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-干掉反射"><a href="#3-干掉反射" class="headerlink" title="3. 干掉反射"></a>3. 干掉反射</h1><p>然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 <code>null</code>，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。</p><p>其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 <code>KProperty0</code> 的 <code>receiver</code> 拿到属性代理对象了，所以我们需要的只是一个<code>WeakHashMap</code>，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 <code>WeakIdentityMap</code> 的集合，对应于有弱引用功能的 <code>IdentityHashMap</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> releasableRefs: WeakIdentityMap&lt;Any, MutableMap&lt;String, ReleasableNotNull&lt;*&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>那么我们只需要在前面的 <code>setValue</code> 当中绑定他们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> map = releasableRefs[thisRef]</span><br><span class="line">            <span class="keyword">if</span>(map == <span class="literal">null</span>)&#123;</span><br><span class="line">                map = HashMap()</span><br><span class="line">                releasableRefs[thisRef] = map</span><br><span class="line">            &#125;</span><br><span class="line">            map[property.name] = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>Map 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">            releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.isInitialized()</span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">        releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-怎么用？"><a href="#4-怎么用？" class="headerlink" title="4. 怎么用？"></a>4. 怎么用？</h1><p>啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 <code>KProperty0</code> 是啥，它其实就是一个顶级变量或者已经绑定完 <code>receiver</code> 的变量，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varInPackage = <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">"World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性我们通过下面的属性引用得到的就是 <code>KProperty0</code> 的实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::varInPackage</span><br><span class="line"></span><br><span class="line">Foo()::bar</span><br></pre></td></tr></table></figure><p>换句话说，我们开头给出的那个 <code>image</code> 的例子就可以这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        image.recycle()</span><br><span class="line">        ::image.release() <span class="comment">// You simply make the backing value null, thus making the gc of this Bitmap instance possible. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-你想直接用？"><a href="#5-你想直接用？" class="headerlink" title="5. 你想直接用？"></a>5. 你想直接用？</h1><p>我已经把这东西扔到 jCenter了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0&quot;</span><br></pre></td></tr></table></figure><p>完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：</p><p><a href="https://github.com/enbandari/ReleasableVar" target="_blank" rel="noopener">https://github.com/enbandari/ReleasableVar</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-题外话：Hadi-的插件&quot;&gt;&lt;a href=&quot;#0-题外话：Hadi-的插件&quot; class=&quot;headerlink&quot; title=&quot;0. 题外话：Hadi 的插件&quot;&gt;&lt;/a&gt;0. 题外话：Hadi 的插件&lt;/h1&gt;&lt;p&gt;上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nyan Process Bar&lt;/li&gt;&lt;li&gt;Presentation Assistant&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也有同学问我ppt的，上周一的文章末尾有提供哈~&lt;/p&gt;&lt;p&gt;好了下面我们言归正传~&lt;/p&gt;&lt;h1 id=&quot;1-描述下需求&quot;&gt;&lt;a href=&quot;#1-描述下需求&quot; class=&quot;headerlink&quot; title=&quot;1. 描述下需求&quot;&gt;&lt;/a&gt;1. 描述下需求&lt;/h1&gt;&lt;p&gt;前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 &lt;code&gt;null&lt;/code&gt;，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Activity &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; image: Bitmap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStart()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = Bitmap.create(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image.recycle()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// You cannot do that!!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018 JetBrains 开发者大会见闻</title>
    <link href="https://www.bennyhuo.com/2018/11/18/2018-JetBrains-Day/"/>
    <id>https://www.bennyhuo.com/2018/11/18/2018-JetBrains-Day/</id>
    <published>2018-11-18T06:23:04.343Z</published>
    <updated>2018-11-18T22:39:53.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。</p></blockquote><p>话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg" alt=""></p><a id="more"></a><p>大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。</p><p>开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）</p><p>JetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg" alt=""></p><p>印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg" alt=""></p><p>还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。</p><p>干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a>）。</p><p>Hadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。</p><p>中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg" alt=""></p><p>因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||</p><p>讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T</p><p>整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。</p><p>Hadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg" alt=""></p><p>还有一个是 Nyan 进度条的插件，很有趣：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg" alt=""></p><p>来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: GitUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，现在我们也可以用 <code>Deferred</code> 来接入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: Deferred&lt;GitUser&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。</p><p>听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)</p><p>不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！</p><p>下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg" alt=""></p><p>这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~</p><p>PS：茶歇的小饼干也很好吃啊！</p><hr><p>下午第一场 “如何优雅地使用数据类” 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~</p><p>链接：<a href="https://share.weiyun.com/5YMPoL4" target="_blank" rel="noopener">https://share.weiyun.com/5YMPoL4</a> 密码：sz4vyw</p><hr><p>Kotlin 中文站：<a href="https://www.kotlincn.net" target="_blank" rel="noopener">https://www.kotlincn.net</a><br>Kotlin 中文博客：<a href="https://www.kotliner.cn" target="_blank" rel="noopener">https://www.kotliner.cn</a><br>Kotlin 中文论坛：<a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">https://discuss.kotliner.cn</a><br>Ktor 中文站：<a href="https://ktor.kotlincn.net" target="_blank" rel="noopener">https://ktor.kotlincn.net</a></p><hr><p>欢迎关注：微信公众号 Kotlin</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>注解处理器教程[全]</title>
    <link href="https://www.bennyhuo.com/2018/10/03/apt-tutorials/"/>
    <id>https://www.bennyhuo.com/2018/10/03/apt-tutorials/</id>
    <published>2018-10-03T02:06:48.914Z</published>
    <updated>2018-11-18T10:24:49.315Z</updated>
    
    <content type="html"><![CDATA[<p>我在做 <a href="https://coding.imooc.com/class/232.html" target="_blank" rel="noopener">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a> 这门课的时候，顺便做了一个注解处理器的框架，叫 <a href="https://github.com/enbandari/TieGuanYin" target="_blank" rel="noopener">Tieguanyin(铁观音)</a>，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 <code>Intent</code> 来传递，有了这个框架我们就可以省去这个麻烦的步骤。</p><p>在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。</p><a id="more"></a><h1 id="视频源码"><a href="#视频源码" class="headerlink" title="视频源码"></a>视频源码</h1><p>见 Github 项目：<a href="https://github.com/enbandari/Apt-Tutorials" target="_blank" rel="noopener">Apt-Tutorials</a></p><h1 id="视频观看"><a href="#视频观看" class="headerlink" title="视频观看"></a>视频观看</h1><h2 id="1-课程简介"><a href="#1-课程简介" class="headerlink" title="1. 课程简介"></a>1. 课程简介</h2><p>作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728uxh61x.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728uxh61x.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=1</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1</a></p><h2 id="2-搭建工程"><a href="#2-搭建工程" class="headerlink" title="2. 搭建工程"></a>2. 搭建工程</h2><p>这一节主要介绍注解处理器工程的结构。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/o07284u5rju.html" target="_blank" rel="noopener">https://v.qq.com/x/page/o07284u5rju.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=2</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2" target="_blank" rel="noopener">https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2</a></p><h2 id="3-解析注解"><a href="#3-解析注解" class="headerlink" title="3. 解析注解"></a>3. 解析注解</h2><p>这一节主要介绍如何解析注解获取被标注的元素信息。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/z07286r97mz.html" target="_blank" rel="noopener">https://v.qq.com/x/page/z07286r97mz.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=3</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3</a></p><h2 id="4-生成常量"><a href="#4-生成常量" class="headerlink" title="4. 生成常量"></a>4. 生成常量</h2><p>这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/k0728tn7sty.html" target="_blank" rel="noopener">https://v.qq.com/x/page/k0728tn7sty.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=4" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=4</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP" target="_blank" rel="noopener">https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP</a></p><h2 id="5-生成-start-方法"><a href="#5-生成-start-方法" class="headerlink" title="5. 生成 start 方法"></a>5. 生成 start 方法</h2><p>这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/x0728j7j7a6.html" target="_blank" rel="noopener">https://v.qq.com/x/page/x0728j7j7a6.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=5" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=5</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5" target="_blank" rel="noopener">https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5</a></p><h2 id="6-生成注入和状态保存的方法"><a href="#6-生成注入和状态保存的方法" class="headerlink" title="6. 生成注入和状态保存的方法"></a>6. 生成注入和状态保存的方法</h2><p>这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/d0728uitqdr.html" target="_blank" rel="noopener">https://v.qq.com/x/page/d0728uitqdr.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=6" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=6</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6" target="_blank" rel="noopener">https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6</a></p><h2 id="7-生成-Kotlin-代码"><a href="#7-生成-Kotlin-代码" class="headerlink" title="7. 生成 Kotlin 代码"></a>7. 生成 Kotlin 代码</h2><p>这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728y2inrf.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728y2inrf.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=7" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=7</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7</a></p><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><p>这一节对整个课程作了一个总结。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/m072848g85p.html" target="_blank" rel="noopener">https://v.qq.com/x/page/m072848g85p.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=8</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8</a></p><hr><p>欢迎关注 Kotlin 公众号：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在做 &lt;a href=&quot;https://coding.imooc.com/class/232.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计&lt;/a&gt; 这门课的时候，顺便做了一个注解处理器的框架，叫 &lt;a href=&quot;https://github.com/enbandari/TieGuanYin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tieguanyin(铁观音)&lt;/a&gt;，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 &lt;code&gt;Intent&lt;/code&gt; 来传递，有了这个框架我们就可以省去这个麻烦的步骤。&lt;/p&gt;&lt;p&gt;在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 社区资源介绍</title>
    <link href="https://www.bennyhuo.com/2018/10/02/kotlin-community-cn/"/>
    <id>https://www.bennyhuo.com/2018/10/02/kotlin-community-cn/</id>
    <published>2018-10-02T02:42:38.566Z</published>
    <updated>2018-11-18T10:24:49.314Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。</p><a id="more"></a><ol><li><strong><a href="https://www.kotlincn.net" target="_blank" rel="noopener">Kotlin 中文官网</a></strong>，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。</li><li><strong><a href="https://www.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文博客</a></strong>，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。</li><li><strong><a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文论坛</a></strong>，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。</li><li><strong>微信公众号 Kotlin</strong>，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。</li></ol><p>欢迎关注 Kotlin 公众号：</p><p><img src="http://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
